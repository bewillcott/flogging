<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="FLogging"><title>flogging - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="flogging" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../flogging/index.html">flogging</a><span class="version">0.6.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#flogging" title="FLogging">FLogging</a><ul><li><a href="#setting-up" title="Setting up">Setting up</a></li><li><a href="#-warning-" title="** Warning **">** Warning **</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></li></ul><h3><a href="#macros-1">Crate Items</a></h3><ul class="block"><li><a href="#macros-1" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>flogging</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/flogging/lib.rs.html#24-379">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="flogging"><a class="doc-anchor" href="#flogging">§</a>FLogging</h2>
<p>The primary purpose of logging, is to facilitate fault diagnosis through the
provision of specific information as, when, and from where, it is needed. This could
be during development, testing, or even during production runs.</p>
<p>There is a new tutorial guide: <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>.</p>
<h3 id="setting-up"><a class="doc-anchor" href="#setting-up">§</a>Setting up</h3>
<p>You need to add this crate to your project:</p>
<div class="example-wrap"><pre class="language-text"><code>$ cargo add flogging</code></pre></div>
<p>or add this text to the projects <code>Cargo.toml</code> file:</p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
flogging = &quot;0.6.0&quot;</code></pre></div><h3 id="-warning-"><a class="doc-anchor" href="#-warning-">§</a>** Warning **</h3>
<p>Before proceeding, please read the <a href="https://crates.io/crates/flogging">README.md</a> file.</p>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<ul>
<li><a href="enum.Level.html">Levels</a> - There are nine (9) levels of message logging, with two (2) special ones.</li>
<li><a href="index.html#choice">Choice</a> - You can use either macros, methods, or a mix of both.</li>
<li><a href="index.html#built-in-options">Built-in options</a> - A range of handlers and formatters.</li>
<li><a href="index.html#customization">Customization</a> - You can create your own handlers and/or formatters.</li>
</ul>
<h4 id="choice"><a class="doc-anchor" href="#choice">§</a>Choice</h4>
<ul>
<li><a href="index.html#macros">Macros</a></li>
<li><a href="index.html#methods">Methods</a></li>
</ul>
<h5 id="macros"><a class="doc-anchor" href="#macros">§</a>Macros</h5>
<ul>
<li><a href="index.html#special-note">Special Note</a></li>
</ul>
<p>This crate has very easy to use macros. By using them, you remove a lot of the complexity
from the process. Thus making it both simpler and less code cluttering, to use.</p>
<ul>
<li>There is one macro (<a href="macro.const_logger.html" title="macro flogging::const_logger"><code>const_logger!()</code></a>) that is used to setup a single module/file for logging.</li>
<li>There is one macro (<a href="attr.logger.html" title="attr flogging::logger"><code>#[logger]</code></a>) that is applied as an attribute to each function/method
that you need to create log entries within.</li>
<li>There are nine macros that are used to actually log the messages:
<ul>
<li><a href="macro.config.html" title="macro flogging::config"><code>config!()</code></a></li>
<li><a href="macro.entering.html" title="macro flogging::entering"><code>entering!()</code></a></li>
<li><a href="macro.exiting.html" title="macro flogging::exiting"><code>exiting!()</code></a></li>
<li><a href="macro.fine.html" title="macro flogging::fine"><code>fine!()</code></a></li>
<li><a href="macro.finer.html" title="macro flogging::finer"><code>finer!()</code></a></li>
<li><a href="macro.finest.html" title="macro flogging::finest"><code>finest!()</code></a></li>
<li><a href="macro.info.html" title="macro flogging::info"><code>info!()</code></a></li>
<li><a href="macro.severe.html" title="macro flogging::severe"><code>severe!()</code></a></li>
<li><a href="macro.warning.html" title="macro flogging::warning"><code>warning!()</code></a></li>
</ul>
</li>
<li>There are two helper macros:
<ul>
<li><a href="macro.get_handler.html" title="macro flogging::get_handler"><code>get_handler!()</code></a></li>
<li><a href="macro.set_level.html" title="macro flogging::set_level"><code>set_level!()</code></a></li>
</ul>
</li>
</ul>
<p>Check out the <a href="index.html#examples">Examples</a> below, or <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>, for how easy it is to get started.</p>
<h6 id="special-note"><a class="doc-anchor" href="#special-note">§</a>Special Note</h6>
<p>For the macros that accept the parameter: <code>msg</code>, the following is true:</p>
<ul>
<li>They accept parameters the same as for <a href="https://doc.rust-lang.org/std/macro.format.html"><code>std::format!</code></a>
<ul>
<li>plain text <code>&amp;str</code>: <code>("It's your time.")</code></li>
<li>format <code>&amp;str</code> with interpolated variables: <code>("Var: {var}")</code></li>
<li>format <code>&amp;str</code> with supporting parameters: <code>("Var: {}", var)</code></li>
<li>Combination of the last two: <code>("Vars {var1} - {}:{}", var2, var3)</code></li>
</ul>
</li>
<li>Additional Feature
<ul>
<li>Just one or more variables without a supplied format string: <code>(var1, var2, var3)</code></li>
<li>In this case, a default format string will be used: <code>"{}, {}, {}"</code></li>
<li>The number of <code>"{}"</code> will depend on the number of parameters.</li>
<li>Ideal for logging concrete instances that have very good <code>Display</code> implementations,
or you just need their data without further explanation.</li>
</ul>
</li>
<li>Special Cases
<ul>
<li><a href="macro.entering.html" title="macro flogging::entering">entering!</a> and <a href="macro.exiting.html" title="macro flogging::exiting">exiting!</a></li>
<li>These two macros have the same features as the others,
but they may also be used <em>without</em> any parameters. In such
a case, their defaults will be used.</li>
</ul>
</li>
</ul>
<h5 id="methods"><a class="doc-anchor" href="#methods">§</a>Methods</h5>
<ul>
<li><a href="index.html#logger">Logger</a></li>
<li><a href="index.html#loggerbuilder">LoggerBuilder</a></li>
</ul>
<p>Now for the coding geeks! Yes I didn’t forget you lot.</p>
<p>Though the macros are the easiest and simplest way to use this crate, those macros are just candy
coating over the real workers, the methods. There are two main mods/structs in this crate, <a href="struct.Logger.html"><code>Logger</code></a>
and <a href="struct.LoggerBuilder.html"><code>LoggerBuilder</code></a>.</p>
<h6 id="logger"><a class="doc-anchor" href="#logger">§</a>Logger</h6>
<p><code>Logger</code> is the work-horse of the crate. It has all the methods for initializing each function/method
for logging, and all of the message logging methods.</p>
<p>Using the “methods” option is more complex, as-in, you have to write a lot more code, and manage it.
To see how much more is involved, check-out the <a href="struct.Logger.html"><code>Logger</code></a>’s methods. There are
plenty of examples throughout.</p>
<ul>
<li><a href="struct.Logger.html#method.builder" title="associated function flogging::Logger::builder"><code>builder()</code></a></li>
<li><a href="struct.Logger.html#method.config" title="method flogging::Logger::config"><code>config()</code></a></li>
<li><a href="struct.Logger.html#method.console_logger" title="associated function flogging::Logger::console_logger"><code>console_logger()</code></a></li>
<li><a href="struct.Logger.html#method.econsole_logger" title="associated function flogging::Logger::econsole_logger"><code>econsole_logger()</code></a></li>
<li><a href="struct.Logger.html#method.custom_logger" title="associated function flogging::Logger::custom_logger"><code>custom_logger()</code></a></li>
<li><a href="struct.Logger.html#method.entering" title="method flogging::Logger::entering"><code>entering()</code></a></li>
<li><a href="struct.Logger.html#method.entering_with" title="method flogging::Logger::entering_with"><code>entering_with()</code></a></li>
<li><a href="struct.Logger.html#method.exiting" title="method flogging::Logger::exiting"><code>exiting()</code></a></li>
<li><a href="struct.Logger.html#method.exiting_with" title="method flogging::Logger::exiting_with"><code>exiting_with()</code></a></li>
<li><a href="struct.Logger.html#method.file_logger" title="associated function flogging::Logger::file_logger"><code>file_logger()</code></a></li>
<li><a href="struct.Logger.html#method.fine" title="method flogging::Logger::fine"><code>fine()</code></a></li>
<li><a href="struct.Logger.html#method.finer" title="method flogging::Logger::finer"><code>finer()</code></a></li>
<li><a href="struct.Logger.html#method.finest" title="method flogging::Logger::finest"><code>finest()</code></a></li>
<li><a href="struct.Logger.html#method.fn_name" title="method flogging::Logger::fn_name"><code>fn_name()</code></a></li>
<li><a href="struct.Logger.html#method.get_handler" title="method flogging::Logger::get_handler"><code>get_handler()</code></a></li>
<li><a href="struct.Logger.html#method.has_handler" title="method flogging::Logger::has_handler"><code>has_handler()</code></a></li>
<li><a href="struct.Logger.html#method.info" title="method flogging::Logger::info"><code>info()</code></a></li>
<li><a href="struct.Logger.html#method.level" title="method flogging::Logger::level"><code>level()</code></a></li>
<li><a href="struct.Logger.html#method.set_fn_name" title="method flogging::Logger::set_fn_name"><code>set_fn_name()</code></a></li>
<li><a href="struct.Logger.html#method.set_level" title="method flogging::Logger::set_level"><code>set_level()</code></a></li>
<li><a href="struct.Logger.html#method.severe" title="method flogging::Logger::severe"><code>severe()</code></a></li>
<li><a href="struct.Logger.html#method.string_logger" title="associated function flogging::Logger::string_logger"><code>string_logger()</code></a></li>
<li><a href="struct.Logger.html#method.warning" title="method flogging::Logger::warning"><code>warning()</code></a></li>
</ul>
<h6 id="loggerbuilder"><a class="doc-anchor" href="#loggerbuilder">§</a>LoggerBuilder</h6>
<p><code>LoggerBuilder</code> is used by <code>Logger</code> to provide various configuration options for setting up your logger.
The available options/methods are:</p>
<ul>
<li><a href="struct.LoggerBuilder.html#method.add_console_handler" title="method flogging::LoggerBuilder::add_console_handler"><code>add_console_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_console_handler_with" title="method flogging::LoggerBuilder::add_console_handler_with"><code>add_console_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_econsole_handler" title="method flogging::LoggerBuilder::add_econsole_handler"><code>add_econsole_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_econsole_handler_with" title="method flogging::LoggerBuilder::add_econsole_handler_with"><code>add_econsole_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_pconsole_handler" title="method flogging::LoggerBuilder::add_pconsole_handler"><code>add_console_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_pconsole_handler_with" title="method flogging::LoggerBuilder::add_pconsole_handler_with"><code>add_console_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_custom_handler" title="method flogging::LoggerBuilder::add_custom_handler"><code>add_custom_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>add_custom_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_file_handler" title="method flogging::LoggerBuilder::add_file_handler"><code>add_file_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_file_handler_with" title="method flogging::LoggerBuilder::add_file_handler_with"><code>add_file_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_string_handler" title="method flogging::LoggerBuilder::add_string_handler"><code>add_string_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_string_handler_with" title="method flogging::LoggerBuilder::add_string_handler_with"><code>add_string_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.remove_file" title="method flogging::LoggerBuilder::remove_file"><code>remove_file()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.set_fn_name" title="method flogging::LoggerBuilder::set_fn_name"><code>set_fn_name()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.set_level" title="method flogging::LoggerBuilder::set_level"><code>set_level()</code></a></li>
</ul>
<p>And to finish:</p>
<ul>
<li><a href="struct.LoggerBuilder.html#method.build" title="method flogging::LoggerBuilder::build"><code>build()</code></a></li>
</ul>
<p>These options/methods allow you a lot of flexibility in how you configure your logger. As you will typically
have a different logger for each mod/file, you have a lot of control over what is logged, how it is formatted,
and where it is stored/viewed. With the <a href="struct.LoggerBuilder.html#method.set_level" title="method flogging::LoggerBuilder::set_level"><code>set_level()</code></a> method, you can control
this on a mod/file basis. Logging each mod/file differently, or even turning logging off when you no-longer require it.</p>
<p>Check out <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong> for examples and further help.</p>
<p><strong>Note</strong></p>
<p>As of version (0.4.0), you can only set the logging level for the logger. All handlers process every log entry
that the logger accepts, based on the logger’s current log level setting. This may change in a future version,
allowing each handler to have its own logging level.</p>
<h4 id="built-in-options"><a class="doc-anchor" href="#built-in-options">§</a>Built-in options</h4>
<p>I have included a number of handlers to get you started:</p>
<ul>
<li><a href="struct.ConsoleHandler.html" title="struct flogging::ConsoleHandler"><code>ConsoleHandler</code></a>
<ul>
<li><a href="enum.ConsoleType.html#variant.StdOut" title="variant flogging::ConsoleType::StdOut"><code>ConsoleType::StdOut</code></a></li>
<li><a href="enum.ConsoleType.html#variant.StdErr" title="variant flogging::ConsoleType::StdErr"><code>ConsoleType::StdErr</code></a></li>
<li><a href="enum.ConsoleType.html#variant.Production" title="variant flogging::ConsoleType::Production"><code>ConsoleType::Production</code></a></li>
</ul>
</li>
<li><a href="struct.FileHandler.html" title="struct flogging::FileHandler"><code>FileHandler</code></a></li>
<li><a href="struct.MockHandler.html" title="struct flogging::MockHandler"><code>MockHandler</code></a></li>
<li><a href="struct.StringHandler.html" title="struct flogging::StringHandler"><code>StringHandler</code></a></li>
</ul>
<p>There are also a number of formatters as well:</p>
<ul>
<li><a href="struct.Iso8601Formatter.html" title="struct flogging::Iso8601Formatter"><code>Iso8601Formatter</code></a></li>
<li><a href="struct.MockFormatter.html" title="struct flogging::MockFormatter"><code>MockFormatter</code></a></li>
<li><a href="struct.SimpleFormatter.html" title="struct flogging::SimpleFormatter"><code>SimpleFormatter</code></a></li>
<li><a href="struct.UnixTimestampFormatter.html" title="struct flogging::UnixTimestampFormatter"><code>UnixTimestampFormatter</code></a></li>
</ul>
<h4 id="customization"><a class="doc-anchor" href="#customization">§</a>Customization</h4>
<ul>
<li><a href="index.html#custom-handler">Custom Handler</a></li>
<li><a href="index.html#custom-formatter">Custom Formatter</a></li>
</ul>
<p>Now for the fun part - “Doing it <em>your</em> way!!!”</p>
<p>Though I have provided some “standard” handlers and formatters, not everyone, or every project,
will want to use them. I expect there will be a need for:</p>
<ul>
<li>sending log entries to remote system log servers,</li>
<li>sending log entries to another program (local or remote) for live analysis, or some other processing,</li>
<li>storing log entries in a specific file format (xml, json, csv),</li>
<li>storing log entries in a database.</li>
</ul>
<p>And I’m sure you’ll come-up with more requirements at some time in the future. So, you have the option
to create your own custom handlers and custom formatters. Mixing them up with the built-in ones as
you need to.</p>
<p>OK now, how do you do it. Well this is going to require some work on your part.</p>
<hr />
<p>For a more in-depth tutorial refer to <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>.</p>
<hr />
<h5 id="custom-handler"><a class="doc-anchor" href="#custom-handler">§</a>Custom Handler</h5>
<p>To create a custom handler, I would suggest looking at the source code for the built-in ones, and copying
the code from the one that is closest to your requirements. <em>Make sure that you rename as appropriate!</em>
Then make the necessary changes, adding in your own code, to get it doing what you need.</p>
<p>When you are ready to try-out your new custom handler, check-out these methods:</p>
<ul>
<li><a href="struct.Logger.html#method.custom_logger" title="associated function flogging::Logger::custom_logger"><code>Logger::custom_logger()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_custom_handler" title="method flogging::LoggerBuilder::add_custom_handler"><code>LoggerBuilder::add_custom_handler()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>LoggerBuilder::add_custom_handler_with()</code></a></li>
</ul>
<h5 id="custom-formatter"><a class="doc-anchor" href="#custom-formatter">§</a>Custom Formatter</h5>
<p>Now for the custom formatter. This may require a bit more investigation on your part, as to the actual
formatting options that are available.</p>
<p>Firstly, this crate uses <a href="https://crates.io/crates/chrono">crono</a> for the date/time functionality. Check
out the available <a href="https://docs.rs/chrono/latest/chrono/format/strftime">specifiers</a>. You will need to use the formatting options from this crate for the <code>dt_fmt</code> string, of your custom
formatter.</p>
<p>Secondly, the <code>fmt_string</code> uses the format options available in accordance with <a href="https://doc.rust-lang.org/1.89.0/alloc/fmt/index.html" title="mod alloc::fmt">std::fmt</a>. Though I am
actually using the <a href="https://crates.io/crates/strfmt">strfmt</a> crate to do the formatting, because it does
<em>not</em> require a ‘static’ string like <code>format!()</code>.</p>
<p>Again, check-out the built-in formatters, and copy the code from the one that is closest to your
requirements. <em>As before, renaming as necessary!</em> Also, check-out the trait: <a href="trait.FormatTrait.html"><code>FormatTrait</code></a>.
You will need to implement it for your custom formatter, as you will notice when you look at the built-in formatters.
Also, you will find that the ‘provided method’, <a href="trait.FormatTrait.html#method.ft_fmt" title="method flogging::FormatTrait::ft_fmt"><code>ft_fmt()</code></a>, provides certain variables
that you can include, via interpolation, in your <code>fmt_string</code>.</p>
<p>Once you have got your custom formatter set up, you can then use it with:</p>
<ul>
<li><a href="struct.LoggerBuilder.html#method.add_console_handler_with" title="method flogging::LoggerBuilder::add_console_handler_with"><code>LoggerBuilder::add_console_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_econsole_handler_with" title="method flogging::LoggerBuilder::add_econsole_handler_with"><code>LoggerBuilder::add_econsole_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_pconsole_handler_with" title="method flogging::LoggerBuilder::add_pconsole_handler_with"><code>LoggerBuilder::add_pconsole_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>LoggerBuilder::add_custom_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_file_handler_with" title="method flogging::LoggerBuilder::add_file_handler_with"><code>LoggerBuilder::add_file_handler_with()</code></a></li>
<li><a href="struct.LoggerBuilder.html#method.add_string_handler_with" title="method flogging::LoggerBuilder::add_string_handler_with"><code>LoggerBuilder::add_string_handler_with()</code></a></li>
</ul>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>This example demonstrates the use of the macros. The reason I am demoing the macros, is that I expect most
people will want to use them, instead of the methods, for ease of use.</p>
<p>Let’s see what is required:</p>
<ol>
<li>At the module/file level:
<ul>
<li><code>use flogging::*;</code></li>
<li><code>const_logger!({...});</code><a href="macro.const_logger.html" title="macro flogging::const_logger">=&gt;</a></li>
</ul>
</li>
<li>On each function/method you want to add logging to:
<ul>
<li><code>#[logger]</code><a href="attr.logger.html" title="attr flogging::logger">=&gt;</a></li>
</ul>
</li>
<li>Inside each such attributed function/method:
<ul>
<li>Any of the logging <a href="index.html#macros-1">macros</a></li>
</ul>
</li>
</ol>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flogging::<span class="kw-2">*</span>;
<span class="kw">use </span>std::{error::Error, result::Result};

<span class="comment">// Setting up the module level logger.
</span><span class="macro">const_logger!</span>({
    Logger::builder(<span class="macro">module_path!</span>())
        .add_console_handler()
        .add_file_handler(<span class="string">"test_logs/debug.log"</span>)
        .set_level(Level::FINEST)
        .build()
});

<span class="attr">#[logger]
</span><span class="kw">fn </span>do_something() {
    <span class="macro">entering!</span>();

    <span class="comment">// do some work worth noting
    </span><span class="kw">let </span>result = <span class="string">"Just something to log."</span>;
    <span class="macro">info!</span>(<span class="string">"Did some work here.\n  {result}"</span>);

    <span class="comment">// ...

    </span><span class="macro">fine!</span>(<span class="string">"Bit more detail."</span>);

    <span class="kw">if let </span><span class="prelude-val">Err</span>(e) = error_prone() {
        <span class="macro">warning!</span>(<span class="string">"Error: {}"</span>, e);
    }

    <span class="macro">exiting!</span>();
}

<span class="attr">#[logger]
</span><span class="kw">fn </span>error_prone() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="macro">entering!</span>();
    <span class="kw">let </span>rtn = <span class="prelude-val">Err</span>(Box::from(<span class="string">"Bad day!"</span>));
    <span class="macro">exiting!</span>();
    rtn
}

<span class="attr">#[logger]
</span><span class="kw">fn </span>main() {
    <span class="macro">entering!</span>();
    <span class="macro">info!</span>(<span class="string">"All logging macros accept the same parameters as `std::format!(...)`"</span>);
    <span class="macro">warning!</span>(<span class="string">"Those same macros (info, etc.) MUST have atleast one parameter."</span>);
    <span class="macro">config!</span>(<span class="string">"This is running on Fedora Linux 42."</span>);
    do_something();
    <span class="macro">info!</span>(<span class="string">"Job's done."</span>);
    <span class="macro">exiting!</span>();
}
</code></pre></div>
<p>Output:</p>
<div class="example-wrap"><pre class="language-code"><code>flogging-&gt;main [FINER  ] Entry
flogging-&gt;main [INFO   ] All logging macros accept the same parameters as `std::format!(...)`
flogging-&gt;main [WARNING] Those same macros (info, etc.) MUST have atleast one parameter.
flogging-&gt;main [CONFIG ] This is running on Fedora Linux 42.
flogging-&gt;do_something [FINER  ] Entry
flogging-&gt;do_something [INFO   ] Did some work here.
  Just something to log.
flogging-&gt;do_something [FINE   ] Bit more detail.
flogging-&gt;error_prone [FINER  ] Entry
flogging-&gt;error_prone [FINER  ] Return
flogging-&gt;do_something [WARNING] Error: Bad day!
flogging-&gt;do_something [FINER  ] Return
flogging-&gt;main [INFO   ] Job&#39;s done.
flogging-&gt;main [FINER  ] Return</code></pre></div></div></details><h2 id="macros-1" class="section-header">Macros<a href="#macros-1" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.config.html" title="macro flogging::config">config</a></dt><dd>Log a CONFIG message.</dd><dt><a class="macro" href="macro.const_logger.html" title="macro flogging::const_logger">const_<wbr>logger</a></dt><dd>Setup module level logger access.</dd><dt><a class="macro" href="macro.entering.html" title="macro flogging::entering">entering</a></dt><dd>Log entry into a function/method.</dd><dt><a class="macro" href="macro.exiting.html" title="macro flogging::exiting">exiting</a></dt><dd>Log return from a function/method.</dd><dt><a class="macro" href="macro.fine.html" title="macro flogging::fine">fine</a></dt><dd>Log a FINE message.</dd><dt><a class="macro" href="macro.finer.html" title="macro flogging::finer">finer</a></dt><dd>Log a FINER message.</dd><dt><a class="macro" href="macro.finest.html" title="macro flogging::finest">finest</a></dt><dd>Log a FINEST message.</dd><dt><a class="macro" href="macro.get_handler.html" title="macro flogging::get_handler">get_<wbr>handler</a></dt><dd>Get the required <code>Handler</code>.</dd><dt><a class="macro" href="macro.info.html" title="macro flogging::info">info</a></dt><dd>Log an INFO message.</dd><dt><a class="macro" href="macro.is_logging.html" title="macro flogging::is_logging">is_<wbr>logging</a></dt><dd>Checks whether or not this logger is processing log requests.</dd><dt><a class="macro" href="macro.set_level.html" title="macro flogging::set_level">set_<wbr>level</a></dt><dd>Set the logging level for this <code>Logger</code> instance.</dd><dt><a class="macro" href="macro.severe.html" title="macro flogging::severe">severe</a></dt><dd>Log a SEVERE message.</dd><dt><a class="macro" href="macro.warning.html" title="macro flogging::warning">warning</a></dt><dd>Log a WARNING message.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ConsoleHandler.html" title="struct flogging::ConsoleHandler">Console<wbr>Handler</a></dt><dd>Publishes log entries to the console.</dd><dt><a class="struct" href="struct.ConsoleTypeError.html" title="struct flogging::ConsoleTypeError">Console<wbr>Type<wbr>Error</a></dt><dd>Returned from <code>FromStr::from_str()</code> when an unknown string
is passed-in.</dd><dt><a class="struct" href="struct.ConsoleTypeIter.html" title="struct flogging::ConsoleTypeIter">Console<wbr>Type<wbr>Iter</a></dt><dd>An iterator over the variants of <a href="enum.ConsoleType.html" title="enum flogging::ConsoleType">ConsoleType</a></dd><dt><a class="struct" href="struct.FileHandler.html" title="struct flogging::FileHandler">File<wbr>Handler</a></dt><dd>Publishes log entries to the file whose name was provided during
initialization.</dd><dt><a class="struct" href="struct.Iso8601Formatter.html" title="struct flogging::Iso8601Formatter">Iso8601<wbr>Formatter</a></dt><dd>ISO 8601 / RFC 3339 date &amp; time format.</dd><dt><a class="struct" href="struct.LogEntry.html" title="struct flogging::LogEntry">LogEntry</a></dt><dd>Used to provide relevant information about each log entry.</dd><dt><a class="struct" href="struct.Logger.html" title="struct flogging::Logger">Logger</a></dt><dd>This is the work-horse, providing the primary methods of the crate.</dd><dt><a class="struct" href="struct.LoggerBuilder.html" title="struct flogging::LoggerBuilder">Logger<wbr>Builder</a></dt><dd>Used by <a href="struct.Logger.html" title="struct flogging::Logger"><code>Logger</code></a> to provide more flexibility in the configuration of the
final logger.</dd><dt><a class="struct" href="struct.MockFormatter.html" title="struct flogging::MockFormatter">Mock<wbr>Formatter</a></dt><dd>Mock Formatter.</dd><dt><a class="struct" href="struct.MockHandler.html" title="struct flogging::MockHandler">Mock<wbr>Handler</a></dt><dd>This is used as a <em>fake</em> or <em>mock</em> handler.</dd><dt><a class="struct" href="struct.SimpleFormatter.html" title="struct flogging::SimpleFormatter">Simple<wbr>Formatter</a></dt><dd>Simple format.</dd><dt><a class="struct" href="struct.StringHandler.html" title="struct flogging::StringHandler">String<wbr>Handler</a></dt><dd>Publishes log entries to an internal list.</dd><dt><a class="struct" href="struct.UnixTimestampFormatter.html" title="struct flogging::UnixTimestampFormatter">Unix<wbr>Timestamp<wbr>Formatter</a></dt><dd>Unix Timestamp format.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.ConsoleType.html" title="enum flogging::ConsoleType">Console<wbr>Type</a></dt><dd><code>ConsoleType</code> configures the <code>ConsoleHandler</code>’s output.</dd><dt><a class="enum" href="enum.FormatType.html" title="enum flogging::FormatType">Format<wbr>Type</a></dt><dd>Used as a simple way to obtain the various <a href="enum.Formatter.html" title="enum flogging::Formatter"><code>Formatter</code></a>s.</dd><dt><a class="enum" href="enum.Formatter.html" title="enum flogging::Formatter">Formatter</a></dt><dd>Provides wrappers for holding each type of formatter.</dd><dt><a class="enum" href="enum.Handler.html" title="enum flogging::Handler">Handler</a></dt><dd>Available handlers.</dd><dt><a class="enum" href="enum.Level.html" title="enum flogging::Level">Level</a></dt><dd>Log entry level setting.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.FormatTrait.html" title="trait flogging::FormatTrait">Format<wbr>Trait</a></dt><dd>Provides methods for formatting <a href="struct.LogEntry.html" title="struct flogging::LogEntry"><code>LogEntry</code></a>s.</dd><dt><a class="trait" href="trait.HandlerTrait.html" title="trait flogging::HandlerTrait">Handler<wbr>Trait</a></dt><dd>Provides common methods required for all handlers.</dd></dl><h2 id="attributes" class="section-header">Attribute Macros<a href="#attributes" class="anchor">§</a></h2><dl class="item-table"><dt><a class="attr" href="attr.logger.html" title="attr flogging::logger">logger</a></dt><dd>Provides for logging within the attributed function/method.</dd></dl></section></div></main></body></html>