<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The FLogging Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The FLogging Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>Flogging</code> provides an easy framework for logging.</p>
<p>Log entries can be sent to the console (stdout or stderr), file, memory log, or a custom handler. They
can be formatted in various layouts: ISO8601, Simple, Unix TimeStamp, or a custom
layout.</p>
<p>Macros and public functions are provided, with the macros being the simplest method
of operation.</p>
<p>There are several levels for logging at:</p>
<ul>
<li>SEVERE,</li>
<li>WARNING,</li>
<li>INFO,</li>
<li>CONFIG,</li>
<li>FINE,</li>
<li>FINER, and</li>
<li>FINEST</li>
</ul>
<p>There are even two special settings:</p>
<ul>
<li>ALL, and</li>
<li>OFF</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>This guide is provided to assist you in both using and customizing <code>FLogging</code>.</p>
<p>For those interested, I have uploaded the complete example project, <a href="https://github.com/bewillcott/my_project" title="" target="_blank">
<code>my_project</code></a>, to Github. It contains all of the code developed throughout this guide. Please note, that each example is stored under a different ‘branch’ of the repository.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use <code>FLogging</code> you have two options:</p>
<ul>
<li>
<p>macros<br />
For simple straight-forward logging.</p>
<p>They are very simple and easy to use, with the minimum of coding required.</p>
</li>
<li>
<p>functions/methods<br />
For when you require more flexibility in your logging regimen.</p>
<p>As an extreme example, you could have separate log tracking for each function/method in your project. For example: separate log files. Though why such separation would be of use I have no idea.</p>
<p>Another example would be, if you only require logging in certain functions, with different requirements, then this could be achieved.</p>
</li>
</ul>
<h2 id="customization"><a class="header" href="#customization">Customization</a></h2>
<p>The available options are:</p>
<ul>
<li>Custom Handlers</li>
<li>Custom Formatters</li>
</ul>
<p>Each of these are independent of the other. You can use custom handlers with the built-in formatters, and custom formatters with the built-in handlers. Or, if you want to be very fancy, you can use your custom formatter with your custom handler!!! What a great idea, hey?</p>
<p>I have tried to make this process as simple as possible.  Though there are many ways I could have gone with this, I decided that having separate modules/files for each one was the easiest and most efficient option, when it comes down to maintainability.</p>
<p>So, let’s get started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macros"><a class="header" href="#macros">Macros</a></h1>
<p>Using macros is easy, simple, and straight-forward.</p>
<p>The following code is the <code>main.rs</code> file from the <code>my_project</code> example, under the <a href="https://github.com/bewillcott/my_project/tree/Usage_Macros" title="" target="_blank">
<code>Usage_Macros</code></a> branch.</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    main.rs
// Directory:    src
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
//! # main file
//!

use flogging::*;
use std::{error::Error, result::Result};

// Setting up the module level logger.
const_logger!({
    Logger::builder(module_path!())
        .add_console_handler()
        .remove_file("test_logs/usage.log")
        .add_file_handler("test_logs/usage.log")
        .set_level(Level::ALL)
        .build()
});

#[logger]
fn do_something() {
    entering!();

    // do some work worth noting
    let result = "Just something to log.";
    info!("Did some work here.\n  {result}");

    // ...

    fine!("Bit more detail.");

    if let Err(e) = error_prone() {
        warning!("Error: {}", e);
    }

    exiting!();
}

#[logger]
fn error_prone() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    entering!();
    let rtn = Err(Box::from("Bad day!"));
    exiting!();
    rtn
}

#[logger]
fn main() {
    entering!();
    info!("All logging macros accept the same parameters as `std::format!(...)`");
    warning!("Those same macros (info, etc.) MUST have atleast one parameter.");
    config!("This is running on Fedora Linux 42.");
    do_something();
    info!("Job's done.");
    exiting!("Bye!");
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD001 MD033 -->
<h1 id="explain-part-1"><a class="header" href="#explain-part-1">Explain (Part 1)</a></h1>
<p>Ok, what’s happening in this code?</p>
<p>Let’s look at the first part:</p>
<pre><code class="language-rust  no_run  noplayground">use flogging::*;
use std::{error::Error, result::Result};

// Setting up the module level logger.
const_logger!({ // &lt;= [1]
    Logger::builder(module_path!())
        .add_console_handler()
        .remove_file("test_logs/usage.log")
        .add_file_handler("test_logs/usage.log")
        .set_level(Level::ALL)
        .build() // &lt;= [2]
}); // &lt;= [1] [3]</code></pre>
<div class="warning">
<p>Some gotchas. Well atleast they keep getting me:</p>
<ul>
<li><code>[1]</code> - You <em>must</em> have the internal braces wrapping the<br />
<code>{ Logger::builder(...) ... }</code> code.</li>
<li><code>[2]</code> - Do <em>not</em> terminate the braced code with a “<code>;</code>”.<br />
In this example, after the <code>.build()</code></li>
<li><code>[3]</code> - Don’t forget the final “<code>;</code>” after the macro: “<code>});</code>”</li>
</ul>
</div>
<p>I think the first two lines are self explanatory.</p>
<p>So let’s dive into the <code>const_logger({...});</code> macro.</p>
<p>The API says:</p>
<pre><code class="language-md">Setup module level logger access.

The basic macro syntax is:

    const_logger!({/* the block of Rust code to build a Logger goes here */});

Notice there are curly braces "{}" wrapping the inner Rust code. **They are required**.

The code you put in here will depend on what configuration of Logger you want to setup.
</code></pre>
<p>As you can see, we are using the <code>Logger::builder(...)</code> method. With this we can be very specific about the logger that we end-up with. Note that this method returns a <code>LoggerBuilder</code> object and <em>not</em> a <code>Logger</code> object. The appended methods, are all implemented under <code>LoggerBuilder</code>. The final method above, <code>build()</code>, returns the fully configured <code>Logger</code> object.</p>
<p>The primary purpose of this macro, is to setup a <strong>mod</strong>/<strong>file</strong> level logger environment. This is required to be able to use the rest of the macros.</p>
<p>If you look into the <a href="guide/macros//api/flogging/struct.LoggerBuilder.html">API</a>, you will find many possible options for your logger configuration.</p>
<hr />
<p><strong>Please note:</strong></p>
<p>It states “module level”.</p>
<p>Each module or file will require its own instance of this setup. This is intentional, to keep things simple to follow and maintain. Each mod/file has a different <code>module_path!</code> which can only be set within its own instance of this setup. Without this distinction, your logs would be an anonymous mess, such that you would not easily know from where a log entry came.</p>
<p>Let’s assume you want to setup just a “global” instance in <code>lib.rs</code>, to be used by all of its “child” mods/files. This is what you might get from logging a function - <code>do_it()</code>:</p>
<pre><code class="language-text">my_project-&gt;do_it [FINER  ] Entry
</code></pre>
<p>or with individual instances (as currently required):</p>
<pre><code class="language-text">my_project::core::control-&gt;do_it [FINER  ] Entry
</code></pre>
<p>where both examples are from the file: <code>src/core/control.rs</code>.</p>
<p>Another reason for separate instances, is that you may want different logger configurations for each one, or atleast, for one or more of them.</p>
<p>One possibility, might be a ‘mod’ that uses <code>add_pconsole_handler()</code>, to be able to have <code>INFO</code> level log entries output to the console without any formatting, like this:</p>
<pre><code class="language-text">This text came from the file `src/core/mod.rs`, just to let you know.
</code></pre>
<p>instead of:</p>
<pre><code class="language-text">my_project::core::mod-&gt;do_it [INFO   ] This text came from the file `src/core/mod.rs`, just to let you know.
</code></pre>
<p>You might set this particular file’s instance to log level <code>Level::INFO</code>, and have regular types of textual output that would be a normal part of the running program.</p>
<p>Mix and match - Have fun!!!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="idea"><a class="header" href="#idea">Idea</a></h1>
<p>How would you like an effective way of controlling all of the logging within the “lib” part of your crate?
Of course, still allowing each mod/file instance to be individually set to its own level.</p>
<p>Let’s say you have something like this project (<a href="https://github.com/bewillcott/my_project/tree/Idea" title="" target="_blank">
<code>my_project</code></a>) structure:</p>
<ul>
<li><code>src/</code>
<ul>
<li><code>lib.rs</code></li>
<li><code>core/</code>
<ul>
<li><code>control.rs</code></li>
<li><code>mod.rs</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>You might have:</p>
<ul>
<li>
<p><code>src/lib.rs</code></p>
<pre><code class="language-rust  no_run  noplayground">mod my_core;

pub(crate) use flogging::*;
pub use my_core::*;

//
// Cargo.toml
//
// [dependencies]
// ctor = "0.5.0"
use ctor::*;

pub(crate) const DEBUG_LEVEL:Level = Level::ALL;
// pub(crate) const DEBUG_LEVEL:Level = Level::OFF;

///
/// Reset the log file each time `my_project` is loaded.
///
/// This is an alternative to using `remove_file()` in
/// the individual mod/file setup commands.\
/// Only useful if all child mods are using the same log file.
///
#[ctor]
fn reset_log(){
    Logger::remove_file("test_logs/usage.log");
}

#[cfg(test)]
mod tests{
    use super::*;

    #[test]
    fn control(){
        my_core::control::do_it();
    }

    #[test]
    fn my_core(){
        my_core::do_it();
    }

}</code></pre>
</li>
<li>
<p><code>src/core/control.rs</code><br />
Notice the use of <code>DEBUG_LEVEL</code>:</p>
<pre><code class="language-rust  no_run  noplayground">use crate::*;

const_logger!({
    Logger::builder(module_path!())
        .add_console_handler()
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        //         ^^^^^^^^^^^
        .build()
});

#[logger]
pub fn do_it() {
    entering!();
    info!("Hello from `Control`.");
    exiting!();
}</code></pre>
</li>
<li>
<p><code>src/core/mod.rs</code><br />
Notice the use of <code>DEBUG_LEVEL</code>, and <code>add_pconsole_handler()</code>:</p>
<pre><code class="language-rust  no_run  noplayground">pub mod control;

use crate::*;

const_logger!({
    Logger::builder(module_path!())
        .add_pconsole_handler()
        //   ^^^^^^^^
        .add_file_handler("test_logs/usage.log")
        // .set_level(Level::INFO)
        .set_level(DEBUG_LEVEL)
        //         ^^^^^^^^^^^
        .build()
});

#[logger]
pub fn do_it() {
    entering!();
    info!("This text came from the file `src/core/mod.rs`, just to let you know.");
    exiting!();
}</code></pre>
</li>
</ul>
<p>The possible output from running the <code>src/lib.rs</code> tests is:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-log">---- tests::control stdout ----
my_project::my_core::control-&gt;do_it [FINER  ] Entry
my_project::my_core::control-&gt;do_it [INFO   ] Hello from `Control`.
my_project::my_core::control-&gt;do_it [FINER  ] Return

---- tests::my_core stdout ----
my_project::my_core-&gt;do_it [FINER  ] Entry
This text came from the file `src/core/mod.rs`, just to let you know.
my_project::my_core-&gt;do_it [FINER  ] Return
</code></pre>
</li>
<li>
<p><code>test_logs/usage.log</code></p>
<pre><code class="language-log">2025-08-27T10:05:48.581421788+08:00 my_project::my_core::control-&gt;do_it [FINER  ] Entry
2025-08-27T10:05:48.581421917+08:00 my_project::my_core-&gt;do_it [FINER  ] Entry
2025-08-27T10:05:48.581505388+08:00 my_project::my_core::control-&gt;do_it [INFO   ] Hello from `Control`.
2025-08-27T10:05:48.581510841+08:00 my_project::my_core-&gt;do_it [INFO   ] This text came from the file `src/core/mod.rs`, just to let you know.
2025-08-27T10:05:48.581528496+08:00 my_project::my_core::control-&gt;do_it [FINER  ] Return
2025-08-27T10:05:48.581533425+08:00 my_project::my_core-&gt;do_it [FINER  ] Return
</code></pre>
</li>
</ul>
<p>Now let’s prepare for a production build.</p>
<p>First we change the global <code>DEBUG_LEVEL</code> to <code>OFF</code>, then we modify <code>src/core/mod.rs</code> to be set to <code>Level::INFO</code>.</p>
<ul>
<li>
<p><code>src/lib.rs</code></p>
<pre><code class="language-rust  no_run  noplayground">...
    pub(crate) const DEBUG_LEVEL:Level = Level::OFF;
...</code></pre>
</li>
<li>
<p><code>src/core/mod.rs</code></p>
<pre><code class="language-rust  no_run  noplayground">...
       .set_level(Level::INFO)
...</code></pre>
</li>
</ul>
<p>Now to see what comes out:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-log">---- tests::my_core stdout ----
This text came from the file `src/core/mod.rs`, just to let you know.
</code></pre>
</li>
<li>
<p><code>test_logs/usage.log</code></p>
<pre><code class="language-log">2025-08-27T10:07:36.124653478+08:00 my_project::my_core-&gt;do_it [INFO   ] This text came from the file `src/core/mod.rs`, just to let you know.
</code></pre>
</li>
</ul>
<p>Next, let’s get rid of the log file (part of <code>src/core/mod.rs</code>):</p>
<pre><code class="language-rust  no_run  noplayground">
...

const_logger!({
    Logger::builder(module_path!())
        .add_pconsole_handler()
        //   ^^^^^^^^
        // .add_file_handler("test_logs/usage.log")
        // .set_level(DEBUG_LEVEL)
        .set_level(Level::INFO)
        //         ^^^^^^^^^^^
        .build()
});

...</code></pre>
<p>And the final production output is:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-log">---- tests::my_core stdout ----
This text came from the file `src/core/mod.rs`, just to let you know.
</code></pre>
</li>
<li>
<p><code>test_logs/usage.log</code></p>
<pre><code class="language-log">
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain-part-2"><a class="header" href="#explain-part-2">Explain (Part 2)</a></h1>
<p>Now the next part of the code:</p>
<pre><code class="language-rust  no_run  noplayground">#[logger]
fn do_something() {
    entering!();

    // do some work worth noting
    let result = "Just something to log.";
    info!("Did some work here.\n  {result}");

    // ...

    fine!("Bit more detail.");

    if let Err(e) = error_prone() {
        warning!("Error: {}", e);
    }

    exiting!();
}</code></pre>
<p>Firstly, the attribute macro: <code>logger</code>.</p>
<p>The API says:</p>
<pre><code class="language-text">Provides for logging within the attributed function/method.

This is required to be able to use the macros. It sets up the local variable used by
the other macros, and it also registers the function/method name used by the log
entries (if included in the formatter’s 'fmt_string').
</code></pre>
<p>This is what handles all of the repetitive coding needed for each of the logged functions/methods.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-up"><a class="header" href="#wrap-up">Wrap Up</a></h1>
<p>Using the macros is simple, coding efficient and tidy. Part of this, is the ability to have a <em>variable number of parameters</em>. As a <strong>Java</strong> programmer, this is something that I miss! In <strong>Rust</strong>, functions/methods don’t have this option. As you will see with <a href="guide/macros/../methods.html"><code>Methods</code></a>, this needs to be handled differently.</p>
<p>In this example, you’ve seen macros with:</p>
<ul>
<li>no parameters (<code>entering!()</code> and <code>exiting()</code>),</li>
<li>a single <code>&amp;str</code> (<code>fine!("Bit more detail.")</code>),</li>
<li>a single <code>&amp;str</code> with an interpolated variable (<code>info!("Did some work here.\n  {result}")</code>),</li>
<li>multiple parameters (<code>warning!("Error: {}", e)</code>)<br />
I understand that this <em>could</em> have been interpolated, but it is shown here as an example of the ability to emulate macros like <code>format!()</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>For when you need greater flexibility than having just the one logger
per mod/file, you have the methods option.</p>
<p>For a comparison, let’s look at redoing the <em>Macros</em> example using the <em>methods</em>.
The following code is the <code>main.rs</code> file from the <code>my_project</code> example, under the <a href="https://github.com/bewillcott/my_project/tree/Usage_Methods" title="" target="_blank">
<code>Usage_Methods</code></a> branch.</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    main.rs
// Directory:    src
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
//! # main file
//!

use flogging::*;
use std::{error::Error, result::Result};

pub(crate) const DEBUG_LEVEL:Level = Level::ALL;

fn do_something() {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("do_something")
        .add_econsole_handler()
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();

    // do some work worth noting
    let result = "Just something to log.";
    log.info(&amp;format!("Did some work here.\n  {result}"));

    // ...

    log.fine("Bit more detail.");

    if let Err(e) = error_prone() {
        log.warning(&amp;format!("Error: {}", e));
    }

    log.exiting();
}

fn error_prone() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("error_prone")
        .add_econsole_handler()
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();
    let rtn = Err(Box::from("Bad day!"));
    log.exiting_with(&amp;format!("{rtn:?}"));
    rtn
}

fn main() {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("main")
        .add_pconsole_handler()
        .remove_file("test_logs/usage.log")
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();
    log.info("All logging macros accept the same parameters as `std::format!(...)`");
    log.warning("Those same macros (info, etc.) MUST have atleast one parameter.");
    log.config("This is running on Fedora Linux 42.");
    do_something();
    log.info("Job's done.");
    log.exiting();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain-part-1-1"><a class="header" href="#explain-part-1-1">Explain (Part 1)</a></h1>
<p>If you compare the code under <code>Methods</code> with that under <code>Macros</code>, you will notice
up front that the macros has a file level ‘logger’, where as the methods has just a
global (crate) level constant (<code>DEBUG_LEVEL</code>).</p>
<p>Now there is <em>nothing</em> stopping you from directly copying all of the expanded macro code
into your files. I would consider that a waste of effort though, as that is what macros are for.</p>
<p>Now then, let’s look at the <code>main()</code> function first:</p>
<pre><code class="language-rust  no_run  noplayground">fn main() {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("main")
        .add_pconsole_handler()
        //   ^^^^^^^^
        .remove_file("test_logs/usage.log")
        //^^^^^^^^^^
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();
    log.info("All logging macros accept the same parameters as `std::format!(...)`");
    log.warning("Those same macros (info, etc.) MUST have atleast one parameter.");
    log.config("This is running on Fedora Linux 42.");
    do_something();
    log.info("Job's done.");
    log.exiting();
}</code></pre>
<p>First, notice the use of both <code>add_pconsole_handler()</code> and <code>remove_file()</code>, in comparison to
the other functions.</p>
<p>The use of <em>pconcole</em> instead of <em>econsole</em>, will have <code>.info()</code> log
entries sent to the ‘stdout’ console, unformatted. This would facilitate providing normal
text messages to the user. Those messages that are part of the normal interaction with the program.
Yet still allowing other log entries to be highlighted as formatted output. And, since there is
also a file handler, of course all messages will go there, formatted.</p>
<p>Having the <code>remove_file()</code> function here, allows you to always have just the entries from
the last run available in the log file. This is <em>not</em> necessary if you need to track entries
over multiple runs. It is here to keep it clean.</p>
<p>The code (<code>Logger::builder...</code>) is basically a copy of that used in the macro version, that sets
up the file level ‘logger’. The main difference is that it also has the <code>.set_fn_name("main")</code>
function, which, among other things, is set by the <code>#[logger]</code> macro in the macro version.</p>
<p>There other differences between the macro and method versions. That being the use of the <code>log</code> variable
to access the logging functionality. Again we have more coding to keep track of.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain-part-2-1"><a class="header" href="#explain-part-2-1">Explain (Part 2)</a></h1>
<p>Now let’s look at the <code>do_something()</code> function.</p>
<pre><code class="language-rust  no_run  noplayground">fn do_something() {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("do_something")
        //^^^^^^^^^^
        .add_econsole_handler()
        //   ^^^^^^^^
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();

    // do some work worth noting
    let result = "Just something to log.";
    log.info(&amp;format!("Did some work here.\n  {result}"));

    // ...

    log.fine("Bit more detail.");

    if let Err(e) = error_prone() {
        log.warning(&amp;format!("Error: {}", e));
    }

    log.exiting();
}</code></pre>
<p>Notice we have the <code>.set_fn_name("do_something")</code> and the <code>.add_econsole_handler()</code>
functions.</p>
<p>We need to set the function name in each function being logged, and in this case, we are sending
entries to the ‘stderr’ console. Also note, that there is no <code>remove_file()</code> function.</p>
<p>The diversity of using different handlers in each function is one of the main reasons for
using the methods over using the macros.</p>
<p>Now we get to one of my personal bug-bears with Rust (v1.88.0). <em>No variable list of parameters
for functions</em>. I have been using Java for many years, and it is a major convenience being
able to have that facility. So, here in this code we see the need to work around that limitation.</p>
<p>Let’s compare  the macro version with the method version:</p>
<pre><code class="language-rust  no_run  noplayground">info!("Did some work here.\n  {result}");</code></pre>
<pre><code class="language-rust  no_run  noplayground">log.info(&amp;format!("Did some work here.\n  {result}"));</code></pre>
<p>The method version requires the text to be preformatted before being passed to it.
Where as, the macro version does that for you, internally.</p>
<p>The same goes for:</p>
<pre><code class="language-rust  no_run  noplayground">warning!("Error: {}", e);</code></pre>
<pre><code class="language-rust  no_run  noplayground">log.warning(&amp;format!("Error: {}", e));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="explain-part-3"><a class="header" href="#explain-part-3">Explain (Part 3)</a></h1>
<p>And finally, we get to the last function.</p>
<pre><code class="language-rust  no_run  noplayground">fn error_prone() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("error_prone")
        .add_econsole_handler()
        .add_file_handler("test_logs/usage.log")
        .set_level(DEBUG_LEVEL)
        .build();

    log.entering();
    let rtn = Err(Box::from("Bad day!"));
    log.exiting_with(&amp;format!("{rtn:?}"));
    rtn
}</code></pre>
<p>I expect you are noticing a pattern here. Boilerplate code everywhere.
Apart from the function name being different in each case, the rest of
the ‘logger’ code is the same as with the <code>do_something()</code> function. And, I
would expect this to be the case for most situations.</p>
<p>We also have a case of using <code>format!()</code> to preformat a message:</p>
<pre><code class="language-rust  no_run  noplayground">log.exiting_with(&amp;format!("{rtn:?}"));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-up-1"><a class="header" href="#wrap-up-1">Wrap Up</a></h1>
<p>The use of the methods directly, requires a lot more coding in general, hence maintenance,
and the inclusion of boilerplating of the ‘logger’ setup.</p>
<p>The primary benefit, is the ability to provide different ‘logger’ configurations for each
function, as needed.</p>
<p>As mentioned in the API, the methods are the backbone of the <code>FLogging</code> crate. The macros
are simply convenient wrappers for them. Thereby removing the need for you to track and maintain
that code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hybrid"><a class="header" href="#hybrid">Hybrid</a></h1>
<p>Now that I have shown you both sides of the <code>Flogging</code> coin, let’s
talk practicality.</p>
<p>Both the macros and the methods have their benefits. The macros are convenient, and
the methods are flexible. So, when needed, why not combine them?</p>
<p>What a great idea! Who would have thought?</p>
<p>So, let’s see what we can do with our example code.</p>
<p>The following code is the <code>main.rs</code> file from the <code>my_project</code> example, under the <a href="https://github.com/bewillcott/my_project/tree/Usage_Hybrid" title="" target="_blank">
<code>Usage_Hybrid</code></a> branch.</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    main.rs
// Directory:    src
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
//! # main file
//!

use flogging::*;
use std::{error::Error, result::Result};

// Setting up the module level logger.
const_logger!({
    Logger::builder(module_path!())
        .add_console_handler()
        .add_file_handler("test_logs/usage.log")
        .set_level(Level::ALL)
        .build()
});

#[logger]
fn do_something() {
    entering!();

    // do some work worth noting
    let result = "Just something to log.";
    info!("Did some work here.\n  {result}");

    // ...

    fine!("Bit more detail.");

    if let Err(e) = error_prone() {
        warning!("Error: {}", e);
    }

    exiting!();
}

#[logger]
fn error_prone() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    entering!();
    let rtn = Err(Box::from("Bad day!"));
    exiting!();
    rtn
}

fn main() {
    let mut log = Logger::builder(module_path!())
        .set_fn_name("main")
        .add_pconsole_handler()
        .remove_file("test_logs/usage.log")
        .add_file_handler("test_logs/usage.log")
        .set_level(Level::ALL)
        .build();

    log.entering();
    log.info("All logging macros accept the same parameters as `std::format!(...)`");
    log.warning("Those same macros (info, etc.) MUST have atleast one parameter.");
    log.config("This is running on Fedora Linux 42.");
    do_something();
    log.info("Job's done.");
    log.exiting();
}</code></pre>
<p>What have I done here?</p>
<p>For the bulk of the functions, in this case, <code>do_something()</code> and <code>error_prone()</code>, I am
using the macros. This prevents the boilerplating and other code bloat problems. Also, I
have removed the <code>remove_file()</code> from the macro setup code.</p>
<p>However, for the <code>main()</code> function, where we want to use the <em>pconsole</em> option, we are
using the methods directly. Notice we are using the same log file for all.</p>
<p>I have used <code>main()</code> to be my ‘methods’ recipient here, but you could have any of your functions
being setup in a similar fashion.</p>
<p>Of course, there is no reason you couldn’t simply have the ‘macro’ setup, using the <em>pconsole</em> option,
and restricting your use of the <code>INFO</code> level logging, to those messages that are expected to be
displayed during the normal use of your program.</p>
<p>In other words, <code>FLogging</code> leaves it entirely up to you and your imagination, or your project’s
requirements, as to how it is used.</p>
<p><em>Mix and match to your hearts desire!</em></p>
<p>P.S.: See what happens when you set the ‘macro’ setup to <code>Level::OFF</code>, and the <code>main()</code> to <code>Level::INFO</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-handlers"><a class="header" href="#custom-handlers">Custom Handlers</a></h1>
<p>Why would you want to create your own handlers?</p>
<p>Well, you tell me!</p>
<p>OK, I suppose I can provide a few reasons. How about:</p>
<ul>
<li>sending log entries to:
<ul>
<li>remote system log servers</li>
<li>another program (local or remote) for live analysis, or some other processing</li>
</ul>
</li>
<li>storing log entries:
<ul>
<li>in a specific file format (xml, json, csv)</li>
<li>in a database</li>
</ul>
</li>
</ul>
<p>Actually, the “file format” option above may only need a custom formatter.
I’ll leave that decision up to you, if you need one of them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-1"><a class="header" href="#step-1">Step 1</a></h1>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>Firstly, you need to know why you want/need to develop a custom handler.</p>
<p>For our example, we are going to develop a simple handler that combines outputting to both the ‘stdout’ console, and a log file. Note, that this would, at best, be a convenience handler, as it would replace two built-in handlers.</p>
<h2 id="how"><a class="header" href="#how">How?</a></h2>
<p>Now you need to know how you would process each log entry, so that you could either send or store it some where, and how you would get it there.</p>
<p>For our example, we need to do two separate things:</p>
<ol>
<li>
<p><code>println!("{}", self.con_fmt.format(log_entry));</code></p>
</li>
<li>
<pre><code class="language-rust  no_run  noplayground">let mut buf = self.file_fmt.format(log_entry);
buf.push('\n');
self.file.as_mut().unwrap().write_all(buf.as_bytes()).expect("writeln!() failed");</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-2"><a class="header" href="#step-2">Step 2</a></h1>
<p>Now we need to check out the existing handlers and their code, to see which one is the
closest to what we are after.</p>
<p>For our example, we could use either the <code>ConsoleHandler</code> or the <code>FileHandler</code>.
As file handling is the more complex task, we will use the <code>FileHandler</code> as our template.</p>
<p>There are two ways to obtain the code. If you are viewing through the on-line <a href="guide/handlers//api/flogging/index.html">API documentation</a>,
then at the top navigation bar, click “flogging-X.X.X”, where “X.X.X” is the version number,
then under “LINKS” click “Source”. This will bring up the “Source” tab. Now we need to navigate
to the required file.</p>
<hr />
<ul>
<li>src
<ul>
<li>handlers
<ul>
<li>file_handler.rs</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>Now select ALL of the code, from the top down, then ‘copy [ctrl/c]’. You need to include the file header (Copyright).</p>
<p>The other way, is to access the github repository: <a href="https://github.com/bewillcott/flogging" title="" target="_blank">flogging</a>. The directory structure is the same as above.</p>
<p>In your project <strong>src</strong> directory somewhere, create your new handler file, and paste this code into it.</p>
<p>For this example, (we’ll name it <a href="https://github.com/bewillcott/my_project/tree/Custom" title="" target="_blank">
<code>my_project</code></a>) we’ll have the following basic layout:</p>
<hr />
<ul>
<li>src/<br />
lib.rs<br />
main.rs
<ul>
<li>handlers/<br />
confile_handler.rs<br />
mod.rs
<ul>
<li>formatters/<br />
csv_formatter.rs</li>
</ul>
</li>
</ul>
</li>
<li>test_logs/</li>
</ul>
<hr />
<p>Our file will be called: <code>confile_handler.rs</code>, with the module: <code>ConfileHandler</code>.</p>
<p>First things first. We now need to do some changes:</p>
<ul>
<li><code>file_handler.rs</code> to <code>confile_handler.rs</code></li>
<li><code>FileHandler</code> to <code>ConfileHandler</code></li>
<li><code>use crate::*;</code> to <code>use flogging::*;</code></li>
</ul>
<p>I have used a form of ‘diff’ to represent the changes:</p>
<pre><code class="language-text"> unchanged code
-  old line code
+  new line code
 unchanged code
</code></pre>
<hr />
<pre><code class="language-rust  no_run  noplayground">
//
- // File Name:    file_handler.rs
+ // File Name:    confile_handler.rs
// Directory:    src/handlers
- // Project Name: flogging
+ // Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
- //! # FileHandler
+ //! # ConfileHandler
//!

use std::{
    fmt,
    fs::{File, exists},
    io::{Error, ErrorKind::InvalidInput, Write},
};

- use crate::*;
+ use flogging::*;

///
/// Publishes log entries to the file whose name was provided during
/// initialization.
///
#[derive(Debug, Default)]
- pub struct FileHandler {
+ pub struct ConfileHandler {
    filename: String,
    formatter: Formatter,
    file: Option&lt;File&gt;,
    writer: Option&lt;Vec&lt;u8&gt;&gt;,
}

- impl FileHandler {
+ impl ConfileHandler {
    fn _create(filename: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        if filename.is_empty() {
            return Err(Error::new(InvalidInput, "'filename' must not be empty"));
        }

-         let fh = FileHandler {
+         let fh = ConfileHandler {
            filename: filename.to_string(),
            formatter: FormatType::Iso8601.create(None),
            file: {
                let f = File::options().append(true).create(true).open(filename)?;
                Some(f)
            },
            writer: None,
        };

        Ok(fh)
    }

    fn log(&amp;self) -&gt; String {
        if let Some(w) = self.writer.to_owned() {
            String::from_utf8(w).unwrap()
        } else {
            String::new()
        }
    }
}

- impl fmt::Display for FileHandler {
+ impl fmt::Display for ConfileHandler {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(f, "{} : {}", self.filename, self.formatter)
    }
}

- impl HandlerTrait for FileHandler {
+ impl HandlerTrait for ConfileHandler {
    ///
    /// Create a new handler instance.
    ///
    /// ## Parameters
    /// - `name` - This the `filename` of the log file.
    ///
    fn create(name: &amp;str) -&gt; Result&lt;Self, Error&gt; {
-         FileHandler::_create(name)
+         ConfileHandler::_create(name)
    }

    ///
    /// Flushes and closes the file.\
    /// Also, removes the internal buffer, if in `test_mode`.\
    /// Will therefore, no longer be *in* `test_mode`.
    ///
    fn close(&amp;mut self) {
        self.flush();
        self.file = None;
    }

    fn flush(&amp;mut self) {
        if let Some(f) = &amp;self.file {
            f.sync_all().expect("sync_all failed");
        }
    }

    fn get_formatter(&amp;self) -&gt; Formatter {
        self.formatter.clone()
    }

    fn get_log(&amp;self) -&gt; String {
        self.log()
    }

    fn is_open(&amp;self) -&gt; bool {
        self.file.is_some()
    }

    fn publish(&amp;mut self, log_entry: &amp;LogEntry) {
        if self.is_open() {
            let mut buf = self.formatter.format(log_entry);
            buf.push('\n');

            if let Some(w) = self.writer.as_mut() {
                writeln!(w, "{}", self.formatter.format(log_entry)).expect("writeln!() failed");
            } else {
                self.file
                    .as_mut()
                    .unwrap()
                    .write_all(buf.as_bytes())
                    .expect("write_all() failed");
            }
        }
    }

    fn set_formatter(&amp;mut self, formatter: Formatter) {
        self.formatter = formatter;
    }

    ///
    /// Sets the test mode to `state`.
    ///
    /// If set to `true`, use `get_log()` to obtain the
    /// log.
    ///
    fn set_test_mode(&amp;mut self, state: bool) {
        if state {
            // true
            self.writer = Some(Vec::new());
        } else {
            self.writer = None;
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::*;
    use std::{
        fs::File,
        io::{Error, Read, Result},
    };

    #[test]
    fn file_handler() {
        let mut log = Logger::file_logger(module_path!(), "test_logs/file_handler.log");
        log.set_fn_name("file_handler");

        let h = log.get_handler(crate::Handler::File).unwrap();
        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let h = log.get_handler(crate::Handler::File).unwrap();

        assert_eq!(h.get_log(), "".to_string());

        h.flush();
        h.close();
        log.exiting_with("This should get thrown away.");
    }

    #[test]
    fn file_handler_file_test() {
        let expected = "flogging::handlers::file_handler::tests-&gt;file_handler_file_test [INFO   ] trait methods
flogging::handlers::file_handler::tests-&gt;file_handler_file_test [WARNING] The sky is falling!\n"
            .to_string();

        let mut log = Logger::builder(module_path!())
            .set_fn_name("file_handler_file_test")
            .remove_file("test_logs/file_handler_file_test.log")
            .add_file_handler_with(
                "test_logs/file_handler_file_test.log",
                FormatType::Simple,
                None,
            )
            .build();

        let h = log.get_handler(crate::Handler::File).unwrap();
        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"\" - fmt_string: \"{mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let h = log.get_handler(crate::Handler::File).unwrap();

        assert_eq!(h.get_log(), "".to_string());

        h.flush();
        h.close();
        assert!(!h.is_open());

        log.severe("This should get thrown away.");

        if let Ok(mut file) = File::open("test_logs/file_handler_file_test.log") {
            let mut buf = String::new();
            if let Ok(_count) = file.read_to_string(&amp;mut buf) {
                assert_eq!(expected, buf);
            }
        }
    }

    #[test]
    fn file_handler_test_mode() {
        let expected = "flogging::handlers::file_handler::tests-&gt;file_handler_test_mode [INFO   ] trait methods
flogging::handlers::file_handler::tests-&gt;file_handler_test_mode [WARNING] The sky is falling!\n"
            .to_string();

        let mut log = Logger::builder(module_path!())
            .set_fn_name("file_handler_test_mode")
            .remove_file("test_logs/file_handler_test_mode.log")
            .add_file_handler_with(
                "test_logs/file_handler_test_mode.log",
                FormatType::Simple,
                None,
            )
            .build();

        let h = log.get_handler(crate::Handler::File).unwrap();
        h.set_test_mode(true);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"\" - fmt_string: \"{mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let h = log.get_handler(crate::Handler::File).unwrap();
        let buf = h.get_log();

        assert_eq!(expected, buf);

        h.flush();
        h.close();
    }

    #[test]
    #[should_panic(expected = "'filename' must not be empty")]
    fn filename_empty() {
        let _ = Logger::file_logger(module_path!(), "");
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-3"><a class="header" href="#step-3">Step 3</a></h1>
<p>With “Step 2” completed, you should be able to build your project without errors.</p>
<p>At this point, our new handler can output to any log file we need.
However, we now need to add the console output component.
For this exercise, we are going to use a different formatter for the console output,
to that for the file output. To keep things simple, we will only provide a “default”
formatter option. That is, there will be no ability to pass-in a different one later.</p>
<p>Firstly, we will need to modify: <code>struct ConfileHandler</code>.</p>
<pre><code class="language-rust  no_run  noplayground">///
/// Publishes log entries to the file whose name was provided during
/// initialization.
///
#[derive(Debug, Default)]
pub struct ConfileHandler {
    filename: String,
-     formatter: Formatter,
+     con_fmt: Formatter,
+     file_fmt: Formatter,
    file: Option&lt;File&gt;,
    writer: Option&lt;Vec&lt;u8&gt;&gt;,
}</code></pre>
<p>Now: <code>impl ConfileHandler</code>.</p>
<pre><code class="language-rust  no_run  noplayground">impl ConfileHandler {
    fn create(filename: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        if filename.is_empty() {
            return Err(Error::new(InvalidInput, "'filename' must not be empty"));
        }

        let fh = ConfileHandler {
            filename: filename.to_string(),
-             formatter: FormatType::Iso8601.create(None),
+             con_fmt: FormatType::Simple.create(None),
+             file_fmt: FormatType::Iso8601.create(None),
            file: {
                let f = File::options().append(true).create(true).open(filename)?;
                Some(f)
            },
            writer: None,
        };

        Ok(fh)
    }
}</code></pre>
<p>Now: <code>impl fmt::Display for ConfileHandler</code>.</p>
<pre><code class="language-rust  no_run  noplayground">impl fmt::Display for ConfileHandler {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
-         write!(f, "{} : {}", self.filename, self.formatter)
+         write!(
+             f,
+             "Console: {}\n{} : {}",
+             self.con_fmt, self.filename, self.file_fmt
+         )

    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-4"><a class="header" href="#step-4">Step 4</a></h1>
<p>Ok, so far so good. Hopefully, your project still builds without errors.</p>
<p>Now we get to the actual working parts.</p>
<p>Firstly, some cleanup. We will make it possible to change the <code>file_fmt</code> once we have developed our custom formatter. So let’s change <code>get_formatter()</code> and <code>set_formatter()</code>.</p>
<pre><code class="language-rust  no_run  noplayground">    fn get_formatter(&amp;self) -&gt; Formatter {
-         self.formatter.clone()
+         self.file_fmt.clone()
    }
</code></pre>
<pre><code class="language-rust  no_run  noplayground">    fn set_formatter(&amp;mut self, formatter: Formatter) {
-         self.formatter = formatter;
+         self.file_fmt = formatter;
    }</code></pre>
<p>Now the final changes:</p>
<pre><code class="language-rust  no_run  noplayground">    fn publish(&amp;mut self, log_entry: &amp;LogEntry) {
        if self.is_open() {
-             let mut buf = self.formatter.format(log_entry);
+             let mut buf = self.file_fmt.format(log_entry);
            buf.push('\n');

            if let Some(w) = self.writer.as_mut() {
-                 writeln!(w, "{}", self.formatter.format(log_entry)).expect("writeln!() failed");
+                 writeln!(w, "{}", self.con_fmt.format(log_entry)).expect("writeln!() failed");
+                 writeln!(w, "{}", self.file_fmt.format(log_entry)).expect("writeln!() failed");
            } else {
+                 println!("{}", self.con_fmt.format(log_entry));
                self.file
                    .as_mut()
                    .unwrap()
                    .write_all(buf.as_bytes())
                    .expect("write_all() failed");
            }
        }
    }</code></pre>
<p>It is done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-5"><a class="header" href="#step-5">Step 5</a></h1>
<p>Oops! Forgot the testing!!!!</p>
<p>Ok, what are we doing with that?</p>
<p>Since we are using a custom handler, we need to use the appropriate methods.</p>
<pre><code class="language-rust  no_run  noplayground">
#[cfg(test)]
mod tests {
-     use crate::*;
-     use std::{
-         fs::File,
-         io::{Error, Read, Result},
-     };

+     use super::*;
+     use std::io::Read;
+     use regex::Regex;</code></pre>
<hr />
<pre><code class="language-rust  no_run  noplayground">    #[test]
-     fn file_handler() {
+     fn confile_handler() {
-         let mut log = Logger::file_logger(module_path!(), "test_logs/file_handler.log");
-         log.set_fn_name("file_handler");
+         let mut log = Logger::custom_logger(
+             module_path!(),
+             "ConfileHandler",
+             Box::new(ConfileHandler::create("test_logs/confile_handler.log").unwrap()),
+         );
+
+         log.set_fn_name("confile_handler");

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();
+
        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();

        assert_eq!(h.get_log(), "".to_string());

        h.flush();
        h.close();
        log.exiting_with("This should get thrown away.");
    }</code></pre>
<p>Possible output:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-text">---- handlers::confile_handler::tests::confile_handler stdout ----
my_project::handlers::confile_handler::tests-&gt;confile_handler [INFO   ] trait methods
my_project::handlers::confile_handler::tests-&gt;confile_handler [WARNING] The sky is falling!
</code></pre>
</li>
<li>
<p>“test_logs/confile_handler.log”<br />
Note: This file will continue to grow. So there maybe previous entries.</p>
<pre><code class="language-text">2025-08-27T11:52:13.273205045+08:00 my_project::handlers::confile_handler::tests-&gt;confile_handler [INFO   ] trait methods
2025-08-27T11:52:13.273294181+08:00 my_project::handlers::confile_handler::tests-&gt;confile_handler [WARNING] The sky is falling!
</code></pre>
</li>
</ul>
<hr />
<pre><code class="language-rust  no_run  noplayground">    #[test]
-     fn file_handler_file_test() {
+     fn confile_handler_file_test() {
-         let expected = "flogging::handlers::file_handler::tests-&gt;file_handler_file_test [INFO   ] trait methods
- flogging::handlers::file_handler::tests-&gt;file_handler_file_test [WARNING] The sky is falling!\n"
-         .to_string();
+         let re_str =
+ "^(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test \\[INFO   ] trait methods
+ (?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test \\[WARNING] The sky is falling!
+ $";
+
+         let re = Regex::new(re_str).unwrap();

        let mut log = Logger::builder(module_path!())
-             .set_fn_name("file_handler_file_test")
-             .remove_file("test_logs/file_handler_file_test.log")
-             .add_file_handler_with(
-                 "test_logs/file_handler_file_test.log",
-                 FormatType::Simple,
-                 None,
-             )
+             .set_fn_name("confile_handler_file_test")
+             .remove_file("test_logs/confile_handler_file_test.log")
+             .add_custom_handler(
+                 "ConfileHandler",
+                 Box::new(
+                     ConfileHandler::create("test_logs/confile_handler_file_test.log").unwrap(),
+                 ),
+             )
            .build();

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(crate::Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();
+
        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
-             "dt_fmt: \"\" - fmt_string: \"{mod_path}-&gt;{fn_name} [{level:7}] {message}\""
+             "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(crate::Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();

        assert_eq!(h.get_log(), "".to_string());

        h.flush();
        h.close();
        assert!(!h.is_open());

        log.severe("This should get thrown away.");

-         if let Ok(mut file) = File::open("test_logs/file_handler_file_test.log") {
+         if let Ok(mut file) = File::open("test_logs/confile_handler_file_test.log") {
            let mut buf = String::new();
            if let Ok(count) = file.read_to_string(&amp;mut buf) {
-                 assert_eq!(expected, buf);
+                 assert!(re.is_match(&amp;buf));
            }
        }
    }</code></pre>
<p>Possible output:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-text">---- handlers::confile_handler::tests::confile_handler_file_test stdout ----
my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test [INFO   ] trait methods
my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test [WARNING] The sky is falling!
</code></pre>
</li>
<li>
<p>“test_logs/confile_handler_file_test.log”</p>
<pre><code class="language-text">2025-08-27T11:54:07.165918573+08:00 my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test [INFO   ] trait methods
2025-08-27T11:54:07.166004387+08:00 my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test [WARNING] The sky is falling!
</code></pre>
</li>
</ul>
<hr />
<pre><code class="language-rust  no_run  noplayground">    #[test]
-     fn file_handler_test_mode() {
+     fn confile_handler_test_mode() {
-         let expected = "flogging::handlers::file_handler::tests-&gt;file_handler_test_mode [INFO   ] trait methods
- flogging::handlers::file_handler::tests-&gt;file_handler_test_mode [WARNING] The sky is falling!\n"
-             .to_string();
+         let re_str =
+ "^my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[INFO   ] trait methods
+ (?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[INFO   ] trait methods
+ my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[WARNING] The sky is falling!
+ (?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[WARNING] The sky is falling!
+ $";
+
+         let re = Regex::new(re_str).unwrap();

        let mut log = Logger::builder(module_path!())
-             .set_fn_name("file_handler_test_mode")
-             .remove_file("test_logs/file_handler_test_mode.log")
-             .add_file_handler_with(
-                 "test_logs/file_handler_test_mode.log",
-                 FormatType::Simple,
-                 None,
-             )
+             .set_fn_name("confile_handler_test_mode")
+             .add_custom_handler(
+                 "ConfileHandler",
+                 Box::new(
+                     // This file is never written to:
+                     ConfileHandler::create("test_logs/confile_handler_test_mode.log").unwrap(),
+                 ),
+             )
            .build();

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(crate::Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();
+
+         // All log entries will be stored in the internal buffer.
        h.set_test_mode(true);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
-             "dt_fmt: \"\" - fmt_string: \"{mod_path}-&gt;{fn_name} [{level:7}] {message}\""
+             "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

-         let h = log.get_handler(crate::Handler::File).unwrap();
+         let h = log
+             .get_handler(crate::Handler::Custom("ConfileHandler".to_string()))
+             .unwrap();
+
        let buf = h.get_log();

-         assert_eq!(expected, buf);
+         assert!(re.is_match(&amp;buf));

        h.flush();
        h.close();
    }</code></pre>
<p>Test passes, but no other output.</p>
<hr />
<pre><code class="language-rust  no_run  noplayground">    #[test]
    #[should_panic(expected = "'filename' must not be empty")]
    fn filename_empty() {
-         let _ = Logger::file_logger(module_path!(), "");
+         let _ = Logger::builder(module_path!())
+             .set_fn_name("confile_handler_test_mode")
+             .add_custom_handler(
+                 "ConfileHandler",
+                 Box::new(
+                     ConfileHandler::create("").unwrap(),
+                 ),
+             )
+             .build();
    }
}</code></pre>
<p>Test passes with output:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-text">thread 'handlers::confile_handler::tests::filename_empty' panicked at src/handlers/confile_handler.rs:323:53:
called `Result::unwrap()` on an `Err` value: Custom { kind: InvalidInput, error: "'filename' must not be empty" }
</code></pre>
</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-code"><a class="header" href="#final-code">Final Code</a></h1>
<p>Here is the complete source code for the custom formatter: <code>ConfileHandler</code>.</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    confile_handler.rs
// Directory:    src/handlers
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
//! # ConfileHandler
//!

use std::{
    fmt,
    fs::{File, exists},
    io::{Error, ErrorKind::InvalidInput, Write},
};

use flogging::*;

///
/// Publishes log entries to the file whose name was provided during
/// initialization.
///
#[derive(Debug, Default)]
pub struct ConfileHandler {
    filename: String,
    con_fmt: Formatter,
    file_fmt: Formatter,
    file: Option&lt;File&gt;,
    writer: Option&lt;Vec&lt;u8&gt;&gt;,
}

impl ConfileHandler {
    fn create(filename: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        if filename.is_empty() {
            return Err(Error::new(InvalidInput, "'filename' must not be empty"));
        }

        let fh = ConfileHandler {
            filename: filename.to_string(),
            con_fmt: FormatType::Simple.create(None),
            file_fmt: FormatType::Iso8601.create(None),
            file: {
                let f = File::options().append(true).create(true).open(filename)?;
                Some(f)
            },
            writer: None,
        };

        Ok(fh)
    }

    fn log(&amp;self) -&gt; String {
        if let Some(w) = self.writer.to_owned() {
            String::from_utf8(w).unwrap()
        } else {
            String::new()
        }
    }
}

impl fmt::Display for ConfileHandler {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "Console: {}\n{} : {}",
            self.con_fmt, self.filename, self.file_fmt
        )
    }
}

impl HandlerTrait for ConfileHandler {
    ///
    /// Create a new handler instance.
    ///
    /// ## Parameters
    /// - `name` - This the `filename` of the log file.
    ///
    fn create(name: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        ConfileHandler::create(name)
    }

    ///
    /// Flushes and closes the file.\
    /// Also, removes the internal buffer, if in `test_mode`.\
    /// Will therefore, no longer be *in* `test_mode`.
    ///
    fn close(&amp;mut self) {
        self.flush();
        self.file = None;
    }

    fn flush(&amp;mut self) {
        if let Some(f) = &amp;self.file {
            f.sync_all().expect("sync_all() failed");
        }
    }

    fn get_formatter(&amp;self) -&gt; Formatter {
        self.file_fmt.clone()
    }

    fn get_log(&amp;self) -&gt; String {
        self.log()
    }

    fn is_open(&amp;self) -&gt; bool {
        self.file.is_some()
    }

    fn publish(&amp;mut self, log_entry: &amp;LogEntry) {
        if self.is_open() {
            let mut buf = self.file_fmt.format(log_entry);
            buf.push('\n');

            if let Some(w) = self.writer.as_mut() {
                writeln!(w, "{}", self.con_fmt.format(log_entry)).expect("writeln!() failed");
                writeln!(w, "{}", self.file_fmt.format(log_entry)).expect("writeln!() failed");
            } else {
                println!("{}", self.con_fmt.format(log_entry));
                self.file.as_mut().unwrap().write_all(buf.as_bytes()).expect("writeln!() failed");
            }
        }
    }

    fn set_formatter(&amp;mut self, formatter: Formatter) {
        self.file_fmt = formatter;
    }

    ///
    /// Sets the test mode to `state`.
    ///
    /// If set to `true`, use `get_log()` to obtain the
    /// log.
    ///
    fn set_test_mode(&amp;mut self, state: bool) {
        if state {
            // true
            self.writer = Some(Vec::new());
        } else {
            self.writer = None;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Read;
    use regex::Regex;

    #[test]
    fn confile_handler() {
        let mut log = Logger::custom_logger(
            module_path!(),
            "ConfileHandler",
            Box::new(ConfileHandler::create("test_logs/confile_handler.log").unwrap()),
        );

        log.set_fn_name("confile_handler");

        let h = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let handler = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        assert_eq!(handler.get_log(), "".to_string());

        handler.flush();
        handler.close();
        log.exiting_with("This should get thrown away.");
    }

    #[test]
    fn confile_handler_file_test() {
        let re_str =
"^(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test \\[INFO   ] trait methods
(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_file_test \\[WARNING] The sky is falling!
$";

        let re = Regex::new(re_str).unwrap();

        let mut log = Logger::builder(module_path!())
            .set_fn_name("confile_handler_file_test")
            .remove_file("test_logs/confile_handler_file_test.log")
            .add_custom_handler(
                "ConfileHandler",
                Box::new(
                    ConfileHandler::create("test_logs/confile_handler_file_test.log").unwrap(),
                ),
            )
            .build();

        let h = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        h.set_test_mode(false);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let h = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        assert_eq!(h.get_log(), "".to_string());

        h.flush();
        h.close();
        assert!(!h.is_open());

        log.severe("This should get thrown away.");

        if let Ok(mut file) = File::open("test_logs/confile_handler_file_test.log") {
            let mut buf = String::new();
            if let Ok(_count) = file.read_to_string(&amp;mut buf) {
                assert!(re.is_match(&amp;buf));
            }
        }
    }

    #[test]
    fn confile_handler_test_mode() {
        let re_str =
"^my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[INFO   ] trait methods
(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[INFO   ] trait methods
my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[WARNING] The sky is falling!
(?:\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{9}\\+\\d{2}:\\d{2}) my_project::handlers::confile_handler::tests-&gt;confile_handler_test_mode \\[WARNING] The sky is falling!
$";
        let re = Regex::new(re_str).unwrap();

        let mut log = Logger::builder(module_path!())
            .set_fn_name("confile_handler_test_mode")
            .add_custom_handler(
                "ConfileHandler",
                Box::new(
                    // This file is never written to:
                    ConfileHandler::create("test_logs/confile_handler_test_mode.log").unwrap(),
                ),
            )
            .build();

        let h = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        // All log entries will be stored in the internal buffer.
        h.set_test_mode(true);

        assert!(h.is_open());
        assert_eq!(
            h.get_formatter().to_string(),
            "dt_fmt: \"%+\" - fmt_string: \"{dt:35} {mod_path}-&gt;{fn_name} [{level:7}] {message}\""
                .to_string()
        );

        log.info("trait methods");
        log.warning("The sky is falling!");

        let h = log
            .get_handler(Handler::Custom("ConfileHandler".to_string()))
            .unwrap();

        let buf = h.get_log();

        assert!(re.is_match(&amp;buf));

        h.flush();
        h.close();
    }

    #[test]
    #[should_panic(expected = "'filename' must not be empty")]
    fn filename_empty() {
        let _ = Logger::builder(module_path!())
            .set_fn_name("confile_handler_test_mode")
            .add_custom_handler(
                "ConfileHandler",
                Box::new(
                    ConfileHandler::create("").unwrap(),
                ),
            )
            .build();
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-up-2"><a class="header" href="#wrap-up-2">Wrap Up</a></h1>
<p>Right … Now we are done. We have our (hopefully) working custom handler, that can be used in our project.</p>
<p>Of course, I expect that your requirements will be more complex.</p>
<p>However, by following this reasonably straightforward process, you should not have too many challenges in getting your custom handler working.</p>
<p>Remember, it’s in the <code>publish()</code> method that all the real work is done. The rest is just setup and support.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-formatters"><a class="header" href="#custom-formatters">Custom Formatters</a></h1>
<p>A custom formatter will allow you to be very specific with the layout of the output for each log entry when it is logged via the log handlers. Though the built-in formatters provide the same options as that provided by the <strong>Java</strong> library, I expect you may have more specific requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-1-1"><a class="header" href="#step-1-1">Step 1</a></h1>
<h2 id="why-1"><a class="header" href="#why-1">Why?</a></h2>
<p>What is the goal, here. What are you trying to achieve?</p>
<p>For our example, we will work towards creating a custom formatter
for outputting a <strong>csv</strong> style format.</p>
<h2 id="how-1"><a class="header" href="#how-1">How?</a></h2>
<p>What is the specific layout that is required?</p>
<p>Our example will aim to provide:</p>
<pre><code class="language-text">&lt;date-time&gt;,&lt;module path&gt;-&gt;&lt;function name&gt;,&lt;level&gt;,"&lt;message&gt;"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-2-1"><a class="header" href="#step-2-1">Step 2</a></h1>
<p>Creating a custom formatter will require some investigation of other crates.
Crates that are used by <code>FLogging</code>:</p>
<ul>
<li><a href="https://crates.io/crates/chrono" title="" target="_blank">crono</a> - Used for the date/time functionality, with its <a href="https://docs.rs/chrono/latest/chrono/format/strftime" title="" target="_blank">specifiers</a>, in</li>
<li>the <code>dt_fmt</code> string of each formatter.</li>
<li><a href="https://doc.rust-lang.org/stable/std/fmt/index.html" title="" target="_blank">std::fmt</a> - The format options used in the <code>fmt_string</code> string of each formatter.</li>
<li><a href="https://crates.io/crates/strfmt" title="" target="_blank">strfmt</a> - Used to do the actual formatting.</li>
</ul>
<p>Now you should check out the built-in formatters to find one that is the closest
to what you are after.</p>
<p>For our example, none of the built-in formatters are really closer than the other, so we will
choose the <code>UnixTimestampFormatter</code>, simply because I am running Linux as my O/S.</p>
<p>To find them, use either the <a href="guide/formatters//api/flogging/index.html">API documentation</a>, or the Github repository: <a href="https://github.com/bewillcott/flogging" title="" target="_blank">flogging</a>.</p>
<p>As with the <a href="guide/formatters/../handlers/step_2.html">Custom Handlers</a>, to obtain the code from the API documentation, at the top
navigation bar, click “flogging-X.X.X”, where “X.X.X” is the version number,
then under “LINKS” click “Source”. This will bring up the “Source” tab.
Now we need to navigate to the required file.</p>
<hr />
<ul>
<li>src
<ul>
<li>handlers
<ul>
<li>formatter
<ul>
<li>unixtimestamp_formatter.rs</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>Now select ALL of the code, from the top down, then ‘copy [ctrl/c]’. You need
to include the file header (Copyright).</p>
<p>In your project <strong>src</strong> directory somewhere, create your new formatter file,
and paste this code into it.</p>
<p>For this example, (we’ll name it <a href="https://github.com/bewillcott/my_project/tree/Custom" title="" target="_blank">
<code>my_project</code></a>) we’ll have the following basic
layout:</p>
<hr />
<ul>
<li>src/<br />
lib.rs<br />
main.rs
<ul>
<li>handlers/<br />
confile_handler.rs<br />
mod.rs
<ul>
<li>formatters/<br />
csv_formatter.rs</li>
</ul>
</li>
</ul>
</li>
<li>test_logs/</li>
</ul>
<hr />
<p>Our file will be called: <code>csv_formatter.rs</code>, with the module: <code>CsvFormatter</code>.</p>
<p>First things first. We now need to do some changes:</p>
<ul>
<li><code>unixtimestamp_formatter.rs</code> to <code>csv_formatter.rs</code></li>
<li><code>UnixTimestampFormatter</code> to <code>CsvFormatter</code></li>
<li><code>use crate::FormatTrait;</code> to <code>use flogging::*;</code></li>
<li><code>&amp;crate::LogEntry</code> to <code>&amp;LogEntry</code></li>
</ul>
<p>I have used a form of ‘diff’ to represent the changes:</p>
<ul>
<li>’- ’ old line code</li>
<li>’+ ’ new line code</li>
</ul>
<pre><code class="language-rust  no_run  noplayground">//
- // File Name:    unixtimestamp_formatter.rs
+ // File Name:    csv_formatter.rs
// Directory:    src/handlers/formatters
- // Project Name: flogging
+ // Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
- //! # UnixTimeStamp Formatter
+ //! # CSV Formatter
//!

use std::fmt;
- use crate::FormatTrait;
+ use flogging::*;

#[derive(Debug, Clone, Hash, PartialEq, Eq)]

///
- /// Unix Timestamp format.
+ /// CSV format.
///
/// The first part (before the decimal point) is
/// the number of seconds since 1970-01-01 00:00 UTC.
///
/// The second part is the number of nanoseconds since
/// the last whole second.
///
/// Example:
/// ```text
/// 1752817859.157970496
/// ```
/// Template:
/// - `dt` in the template would be the datetime string, similar to the above.
/// - `mod_path`, `fn_name`, `level`, and `message` all come out of the `LogEntry`
- ///   provided to the [`format()`][UnixTimestampFormatter::format] method.
+ ///   provided to the [`format()`][CsvFormatter::format] method.
///
/// ```ignore
/// format!("{dt} {mod_path}-&gt;{fn_name} [{level:7}] {message}");
/// ```
/// Sample output:
/// ```text
/// 1752818461.051538870 flogging-&gt;main [SEVERE ] Hurricanes are windy!
/// ```
///
- pub struct UnixTimestampFormatter {
+ pub struct CsvFormatter {
    dt_fmt: String,
    fmt_string: String,
}

- impl UnixTimestampFormatter {
+ impl CsvFormatter {
    ///
-    /// Creates a new instance of `UnixTimestampFormatter`.
+    /// Creates a new instance of `CsvFormatter`.
    ///
    pub fn new() -&gt; Self {
        Self {
            dt_fmt: "%s.%f".to_string(),
            fmt_string: "{dt} {mod_path}-&gt;{fn_name} [{level:7}] {message}".to_string(),
        }
    }

    ///
    /// Returns the date/time format string.
    ///
    pub fn dt_fmt(&amp;self) -&gt; String {
        self.dt_fmt.clone()
    }

    ///
    /// Returns the primary format string.
    ///
    pub fn fmt_string(&amp;self) -&gt; String {
        self.fmt_string.clone()
    }
}

- impl Default for UnixTimestampFormatter {
+ impl Default for CsvFormatter {
    fn default() -&gt; Self {
        Self::new()
    }
}

- impl fmt::Display for UnixTimestampFormatter {
+ impl fmt::Display for CsvFormatter {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "dt_fmt: \"{}\" - fmt_string: \"{}\"",
            self.dt_fmt, self.fmt_string
        )
    }
}

- impl FormatTrait for UnixTimestampFormatter {
+ impl FormatTrait for CsvFormatter {
-     fn format(&amp;self, log_entry: &amp;crate::LogEntry) -&gt; String {
+     fn format(&amp;self, log_entry: &amp;LogEntry) -&gt; String {
        self.ft_fmt(self.dt_fmt(), self.fmt_string(), log_entry)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-3-1"><a class="header" href="#step-3-1">Step 3</a></h1>
<p>At this point your project should still build without errors.</p>
<p>Next, let’s put together the datetime format string: <code>dt_fmt</code>.</p>
<p>After looking into the <code>crono</code> crates specifiers, we come up with this string:</p>
<pre><code class="language-text">"%Y-%m-%d %H:%M:%S%.6f"
</code></pre>
<p>which should produce something like:</p>
<pre><code class="language-text">2025-06-23 13:10:45.123456
</code></pre>
<p>Now, let’s build the main format string: <code>fmt_string</code>.</p>
<p>First, look at the provided method: <code>FormatTrait::ft_fmt()</code>. It provides the following variables that can be included in your format string via interpolation:</p>
<ul>
<li><code>dt</code> - The datetime formatted with: <code>dt_fmt</code>.</li>
<li><code>mod_path</code> - The module path, possibly supplied via: <code>module_path!()</code>.</li>
<li><code>fn_name</code> - The name of the function/method inside which the log entry was generated. Supplied by the <code>#[logger]</code> macro, or manually with the <code>set_fn_name()</code> method.</li>
<li><code>level</code> - The log <code>Level</code> for which the entry was created.</li>
<li><code>message</code> - The text of the log entry.</li>
</ul>
<p>Using the specifiers available in <code>std:fmt</code>, we produce this:</p>
<pre><code class="language-text">"{dt},{mod_path}-&gt;{fn_name},{level},\"{message}\""
</code></pre>
<p>with a possible output of:</p>
<pre><code class="language-text">2025-06-23 13:10:45.123456,my_project::csv_formatter::tests-&gt;csv_format,INFO,"trait methods"
</code></pre>
<p>Using these format strings, we can now modify our new custom formatter as follows:</p>
<pre><code class="language-rust  no_run  noplayground">impl CsvFormatter {
    ///
    /// Creates a new instance of `CsvFormatter`.
    ///
    pub fn new() -&gt; Self {
        Self {
-            dt_fmt: "%s.%f".to_string(),
+            dt_fmt: "%Y-%m-%d %H:%M:%S%.6f".to_string(),
-            fmt_string: "{dt} {mod_path}-&gt;{fn_name} [{level:7}] {message}".to_string(),
+            fmt_string: "{dt},{mod_path}-&gt;{fn_name},{level},\"{message}\"".to_string(),
        }
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step-4-1"><a class="header" href="#step-4-1">Step 4</a></h1>
<p>Let’s add some testing:</p>
<pre><code class="language-rust no_run  noplayground">#[cfg(test)]
mod tests{
    use super::*;
    use regex::Regex;

    const_logger!({
        Logger::builder(module_path!())
            .add_string_handler_with(
                FormatType::Custom,
                Some(Box::new(CsvFormatter::new())),
            )
            .build()
    });

    #[test]
    #[logger]
    fn csv_format() {
        entering!();

        let re_str =
"^(?:\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{6}),my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,INFO,\"Testing a new custom formatter.\"
(?:\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{6}),my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,WARNING,\"Must add more testing.\"
$";

        let re = Regex::new(re_str).unwrap();

        info!("Testing a new custom formatter.");
        warning!("Must add more testing.");

        let log_str = get_handler!(Handler::String).unwrap().get_log();

        println!("{log_str}");
        assert!(re.is_match(&amp;log_str));
    }
}</code></pre>
<p>Possible output:</p>
<pre><code class="language-text">---- handlers::formatters::csv_formatter::tests::csv_format stdout ----
2025-08-27 12:15:48.853979,my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,INFO,"Testing a new custom formatter."
2025-08-27 12:15:48.854052,my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,WARNING,"Must add more testing."
</code></pre>
<p>Now let’s do a final fixup of the API comments.</p>
<pre><code class="language-rust  no_run  noplayground">///
/// CSV format.
///
- /// The first part (before the decimal point) is
- /// the number of seconds since 1970-01-01 00:00 UTC.
- ///
- /// The second part is the number of nanoseconds since
- /// the last whole second.
+ /// The datetime format string is:
+ ///
+ /// ```text
+ /// "%Y-%m-%d %H:%M:%S%.6f"
+ /// ```
///
/// Example:
/// ```text
- /// 1752817859.157970496
+ /// 2025-08-21 19:15:04.089061
/// ```
/// Template:
/// - `dt` in the template would be the datetime string, similar to the above.
/// - `mod_path`, `fn_name`, `level`, and `message` all come out of the `LogEntry`
///   provided to the [`format()`][CsvFormatter::format] method.
///
/// ```ignore
- /// format!("{dt} {mod_path}-&gt;{fn_name} [{level:7}] {message}");
+ /// format!("{dt},{mod_path}-&gt;{fn_name},{level},\"{message}\"");
/// ```
/// Sample output:
/// ```text
- /// 1752818461.051538870 flogging-&gt;main [SEVERE ] Hurricanes are windy!
+ /// 2025-08-21 19:26:47.801287,my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,SEVERE,"Hurricanes are windy!"
/// ```
///
pub struct CsvFormatter {
    dt_fmt: String,
    fmt_string: String,
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-code-1"><a class="header" href="#final-code-1">Final Code</a></h1>
<p>Here is the complete source code for the custom formatter: <code>CsvFormatter</code>.</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    csv_formatter.rs
// Directory:    src/handlers/formatters
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

//!
//! # CSV Formatter
//!

use std::fmt;
use flogging::*;

#[derive(Debug, Clone, Hash, PartialEq, Eq)]

///
/// CSV format.
///
/// The datetime format string is:
///
/// ```text
/// "%Y-%m-%d %H:%M:%S%.6f"
/// ```
///
/// Example:
/// ```text
/// 2025-08-21 19:15:04.089061
/// ```
/// Template:
/// - `dt` in the template would be the datetime string, similar to the above.
/// - `mod_path`, `fn_name`, `level`, and `message` all come out of the `LogEntry`
///   provided to the [`format()`][CsvFormatter::format] method.
///
/// ```ignore
/// format!("{dt},{mod_path}-&gt;{fn_name},{level},\"{message}\"");
/// ```
/// Sample output:
/// ```text
/// 2025-08-21 19:26:47.801287,my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,SEVERE,"Hurricanes are windy!"
/// ```
///
pub struct CsvFormatter {
    dt_fmt: String,
    fmt_string: String,
}

impl CsvFormatter {
    ///
    /// Creates a new instance of `CsvFormatter`.
    ///
    pub fn new() -&gt; Self {
        Self {
            dt_fmt: "%Y-%m-%d %H:%M:%S%.6f".to_string(),
            fmt_string: "{dt},{mod_path}-&gt;{fn_name},{level},\"{message}\"".to_string(),
        }
    }

    ///
    /// Returns the date/time format string.
    ///
    pub fn dt_fmt(&amp;self) -&gt; String {
        self.dt_fmt.clone()
    }

    ///
    /// Returns the primary format string.
    ///
    pub fn fmt_string(&amp;self) -&gt; String {
        self.fmt_string.clone()
    }
}

impl Default for CsvFormatter {
    fn default() -&gt; Self {
        Self::new()
    }
}

impl fmt::Display for CsvFormatter {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        write!(
            f,
            "dt_fmt: \"{}\" - fmt_string: \"{}\"",
            self.dt_fmt, self.fmt_string
        )
    }
}

impl FormatTrait for CsvFormatter {
    fn format(&amp;self, log_entry: &amp;LogEntry) -&gt; String {
        self.ft_fmt(self.dt_fmt(), self.fmt_string(), log_entry)
    }
}

#[cfg(test)]
mod tests{
    use super::*;
    use regex::Regex;

    const_logger!({
        Logger::builder(module_path!())
            .add_string_handler_with(
                FormatType::Custom,
                Some(Box::new(CsvFormatter::new())),
            )
            .build()
    });

    #[test]
    #[logger]
    fn csv_format() {
        entering!();

        let re_str =
"^(?:\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{6}),my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,INFO,\"Testing a new custom formatter.\"
(?:\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{6}),my_project::handlers::formatters::csv_formatter::tests-&gt;csv_format,WARNING,\"Must add more testing.\"
$";

        let re = Regex::new(re_str).unwrap();

        info!("Testing a new custom formatter.");
        warning!("Must add more testing.");

        let log_str = get_handler!(Handler::String).unwrap().get_log();

        println!("{log_str}");
        assert!(re.is_match(&amp;log_str));
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wrap-up-3"><a class="header" href="#wrap-up-3">Wrap Up</a></h1>
<p>Alright! We are done.</p>
<p>Hopefully, by following all these steps, your own custom formatter should build and perform its duty correctly.</p>
<p>In developing the example formatter, I found out that the <code>crono</code> specifiers are very specific. Atleast <code>%.3f</code>, etc. I tried to use: <code>%.4f</code> and it did <em>not</em> like it. Since <code>3</code> was too small, I had to go for <code>6</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration"><a class="header" href="#integration">Integration</a></h1>
<p>Now that we have our custom handler and formatter, let’s use them.</p>
<p>For those interested, I have uploaded the whole example project to:</p>
<p><a href="https://github.com/bewillcott/my_project/tree/Custom" target="_blank">https://github.com/bewillcott/my_project/tree/Custom</a>.</p>
<p>Here is the sample main.rs:</p>
<pre><code class="language-rust  no_run  noplayground">//
// File Name:    main.rs
// Directory:    src
// Project Name: my_project
//
// Copyright (C) 2025 Bradley Willcott
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This library (crate) is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This library (crate) is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this library (crate).  If not, see &lt;https://www.gnu.org/licenses/&gt;.
//

use my_project::*;

const_logger!({
    Logger::builder(module_path!())
        .remove_file("test_logs/debug.log")
        .add_custom_handler_with(
            "ConfileHandler",
            Box::new(ConfileHandler::create("test_logs/debug.log").unwrap()),
            FormatType::Custom,
            Some(Box::new(CsvFormatter::new())),
        )
        .set_level(Level::ALL)
        .build()
});

#[logger]
fn main() {
    entering!();

    config!("Operating system: Fedora Linux");
    config!("Version: 42");

    info!("This is a test of the integration of the 'FLogging crate' and the custom handler and formatter.");

    println!("*** My Project ***");

    exiting!();
}</code></pre>
<p>Sample output:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-text">my_project-&gt;main [FINER  ] Entry
my_project-&gt;main [CONFIG ] Operating system: Fedora Linux
my_project-&gt;main [CONFIG ] Version: 42
my_project-&gt;main [INFO   ] This is a test of the integration of the 'FLogging crate' and the custom handler and formatter.
*** My Project ***
my_project-&gt;main [FINER  ] Return
</code></pre>
</li>
<li>
<p><code>test_logs/debug.log</code></p>
<pre><code class="language-text">2025-08-27 12:22:28.291102,my_project-&gt;main,FINER,"Entry"
2025-08-27 12:22:28.291180,my_project-&gt;main,CONFIG,"Operating system: Fedora Linux"
2025-08-27 12:22:28.291205,my_project-&gt;main,CONFIG,"Version: 42"
2025-08-27 12:22:28.291226,my_project-&gt;main,INFO,"This is a test of the integration of the 'FLogging crate' and the custom handler and formatter."
2025-08-27 12:22:28.291255,my_project-&gt;main,FINER,"Return"
</code></pre>
</li>
</ul>
<p>Now let’s see what we get when we turn <code>OFF</code> logging:</p>
<pre><code class="language-rust  no_run  noplayground">const_logger!({
    Logger::builder(module_path!())
        .remove_file("test_logs/debug.log")
        .add_custom_handler_with(
            "ConfileHandler",
            Box::new(ConfileHandler::create("test_logs/debug.log").unwrap()),
            FormatType::Custom,
            Some(Box::new(CsvFormatter::new())),
        )
-         .set_level(Level::ALL)
+         .set_level(Level::OFF)
        .build()
});</code></pre>
<p>Sample output:</p>
<ul>
<li>
<p>console</p>
<pre><code class="language-text">*** My Project ***
</code></pre>
</li>
<li>
<p><code>test_logs/debug.log</code></p>
<pre><code class="language-text">
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="FLogging"><title>flogging - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="flogging" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0 (29483883e 2025-08-04)" data-channel="1.89.0" data-search-js="search-92309212.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2 id="flogging060"><a class="header" href="#flogging060"><a href="api/flogging/../flogging/index.html">flogging</a><span class="version">0.6.0</span></a></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="api/flogging/all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3 id="sections"><a class="header" href="#sections"><a href="api/flogging/index.html#">Sections</a></a></h3><ul class="block top-toc"><li><a href="api/flogging/index.html#flogging" title="FLogging">FLogging</a><ul><li><a href="api/flogging/index.html#setting-up" title="Setting up">Setting up</a></li><li><a href="api/flogging/index.html#-warning-" title="** Warning **">** Warning **</a></li><li><a href="api/flogging/index.html#features" title="Features">Features</a></li><li><a href="api/flogging/index.html#examples" title="Examples">Examples</a></li></ul></li></ul><h3 id="crate-items"><a class="header" href="#crate-items"><a href="api/flogging/index.html#macros-1">Crate Items</a></a></h3><ul class="block"><li><a href="api/flogging/index.html#macros-1" title="Macros">Macros</a></li><li><a href="api/flogging/index.html#structs" title="Structs">Structs</a></li><li><a href="api/flogging/index.html#enums" title="Enums">Enums</a></li><li><a href="api/flogging/index.html#traits" title="Traits">Traits</a></li><li><a href="api/flogging/index.html#attributes" title="Attribute Macros">Attribute Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1 id="crate-floggingcopy-item-path"><a class="header" href="#crate-floggingcopy-item-path">Crate <span>flogging</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></a></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="api/flogging/../src/flogging/lib.rs.html#24-379">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="flogging"><a class="header" href="#flogging"><a class="doc-anchor" href="api/flogging/index.html#flogging">§</a>FLogging</a></h2>
<p>The primary purpose of logging, is to facilitate fault diagnosis through the
provision of specific information as, when, and from where, it is needed. This could
be during development, testing, or even during production runs.</p>
<p>There is a new tutorial guide: <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>.</p>
<h3 id="setting-up"><a class="header" href="#setting-up"><a class="doc-anchor" href="api/flogging/index.html#setting-up">§</a>Setting up</a></h3>
<p>You need to add this crate to your project:</p>
<div class="example-wrap"><pre class="language-text"><code>$ cargo add flogging</code></pre></div>
<p>or add this text to the projects <code>Cargo.toml</code> file:</p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
flogging = &quot;0.6.0&quot;</code></pre></div><h3 id="-warning-"><a class="header" href="#-warning-"><a class="doc-anchor" href="api/flogging/index.html#-warning-">§</a>** Warning **</a></h3>
<p>Before proceeding, please read the <a href="https://crates.io/crates/flogging">README.md</a> file.</p>
<h3 id="features"><a class="header" href="#features"><a class="doc-anchor" href="api/flogging/index.html#features">§</a>Features</a></h3>
<ul>
<li><a href="api/flogging/enum.Level.html">Levels</a> - There are nine (9) levels of message logging, with two (2) special ones.</li>
<li><a href="api/flogging/index.html#choice">Choice</a> - You can use either macros, methods, or a mix of both.</li>
<li><a href="api/flogging/index.html#built-in-options">Built-in options</a> - A range of handlers and formatters.</li>
<li><a href="api/flogging/index.html#customization">Customization</a> - You can create your own handlers and/or formatters.</li>
</ul>
<h4 id="choice"><a class="header" href="#choice"><a class="doc-anchor" href="api/flogging/index.html#choice">§</a>Choice</a></h4>
<ul>
<li><a href="api/flogging/index.html#macros">Macros</a></li>
<li><a href="api/flogging/index.html#methods">Methods</a></li>
</ul>
<h5 id="macros"><a class="header" href="#macros"><a class="doc-anchor" href="api/flogging/index.html#macros">§</a>Macros</a></h5>
<ul>
<li><a href="api/flogging/index.html#special-note">Special Note</a></li>
</ul>
<p>This crate has very easy to use macros. By using them, you remove a lot of the complexity
from the process. Thus making it both simpler and less code cluttering, to use.</p>
<ul>
<li>There is one macro (<a href="api/flogging/macro.const_logger.html" title="macro flogging::const_logger"><code>const_logger!()</code></a>) that is used to setup a single module/file for logging.</li>
<li>There is one macro (<a href="api/flogging/attr.logger.html" title="attr flogging::logger"><code>#[logger]</code></a>) that is applied as an attribute to each function/method
that you need to create log entries within.</li>
<li>There are nine macros that are used to actually log the messages:
<ul>
<li><a href="api/flogging/macro.config.html" title="macro flogging::config"><code>config!()</code></a></li>
<li><a href="api/flogging/macro.entering.html" title="macro flogging::entering"><code>entering!()</code></a></li>
<li><a href="api/flogging/macro.exiting.html" title="macro flogging::exiting"><code>exiting!()</code></a></li>
<li><a href="api/flogging/macro.fine.html" title="macro flogging::fine"><code>fine!()</code></a></li>
<li><a href="api/flogging/macro.finer.html" title="macro flogging::finer"><code>finer!()</code></a></li>
<li><a href="api/flogging/macro.finest.html" title="macro flogging::finest"><code>finest!()</code></a></li>
<li><a href="api/flogging/macro.info.html" title="macro flogging::info"><code>info!()</code></a></li>
<li><a href="api/flogging/macro.severe.html" title="macro flogging::severe"><code>severe!()</code></a></li>
<li><a href="api/flogging/macro.warning.html" title="macro flogging::warning"><code>warning!()</code></a></li>
</ul>
</li>
<li>There are two helper macros:
<ul>
<li><a href="api/flogging/macro.get_handler.html" title="macro flogging::get_handler"><code>get_handler!()</code></a></li>
<li><a href="api/flogging/macro.set_level.html" title="macro flogging::set_level"><code>set_level!()</code></a></li>
</ul>
</li>
</ul>
<p>Check out the <a href="api/flogging/index.html#examples">Examples</a> below, or <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>, for how easy it is to get started.</p>
<h6 id="special-note"><a class="header" href="#special-note"><a class="doc-anchor" href="api/flogging/index.html#special-note">§</a>Special Note</a></h6>
<p>For the macros that accept the parameter: <code>msg</code>, the following is true:</p>
<ul>
<li>They accept parameters the same as for <a href="https://doc.rust-lang.org/std/macro.format.html"><code>std::format!</code></a>
<ul>
<li>plain text <code>&amp;str</code>: <code>("It's your time.")</code></li>
<li>format <code>&amp;str</code> with interpolated variables: <code>("Var: {var}")</code></li>
<li>format <code>&amp;str</code> with supporting parameters: <code>("Var: {}", var)</code></li>
<li>Combination of the last two: <code>("Vars {var1} - {}:{}", var2, var3)</code></li>
</ul>
</li>
<li>Additional Feature
<ul>
<li>Just one or more variables without a supplied format string: <code>(var1, var2, var3)</code></li>
<li>In this case, a default format string will be used: <code>"{}, {}, {}"</code></li>
<li>The number of <code>"{}"</code> will depend on the number of parameters.</li>
<li>Ideal for logging concrete instances that have very good <code>Display</code> implementations,
or you just need their data without further explanation.</li>
</ul>
</li>
<li>Special Cases
<ul>
<li><a href="api/flogging/macro.entering.html" title="macro flogging::entering">entering!</a> and <a href="api/flogging/macro.exiting.html" title="macro flogging::exiting">exiting!</a></li>
<li>These two macros have the same features as the others,
but they may also be used <em>without</em> any parameters. In such
a case, their defaults will be used.</li>
</ul>
</li>
</ul>
<h5 id="methods"><a class="header" href="#methods"><a class="doc-anchor" href="api/flogging/index.html#methods">§</a>Methods</a></h5>
<ul>
<li><a href="api/flogging/index.html#logger">Logger</a></li>
<li><a href="api/flogging/index.html#loggerbuilder">LoggerBuilder</a></li>
</ul>
<p>Now for the coding geeks! Yes I didn’t forget you lot.</p>
<p>Though the macros are the easiest and simplest way to use this crate, those macros are just candy
coating over the real workers, the methods. There are two main mods/structs in this crate, <a href="api/flogging/struct.Logger.html"><code>Logger</code></a>
and <a href="api/flogging/struct.LoggerBuilder.html"><code>LoggerBuilder</code></a>.</p>
<h6 id="logger"><a class="header" href="#logger"><a class="doc-anchor" href="api/flogging/index.html#logger">§</a>Logger</a></h6>
<p><code>Logger</code> is the work-horse of the crate. It has all the methods for initializing each function/method
for logging, and all of the message logging methods.</p>
<p>Using the “methods” option is more complex, as-in, you have to write a lot more code, and manage it.
To see how much more is involved, check-out the <a href="api/flogging/struct.Logger.html"><code>Logger</code></a>’s methods. There are
plenty of examples throughout.</p>
<ul>
<li><a href="api/flogging/struct.Logger.html#method.builder" title="associated function flogging::Logger::builder"><code>builder()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.config" title="method flogging::Logger::config"><code>config()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.console_logger" title="associated function flogging::Logger::console_logger"><code>console_logger()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.econsole_logger" title="associated function flogging::Logger::econsole_logger"><code>econsole_logger()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.custom_logger" title="associated function flogging::Logger::custom_logger"><code>custom_logger()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.entering" title="method flogging::Logger::entering"><code>entering()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.entering_with" title="method flogging::Logger::entering_with"><code>entering_with()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.exiting" title="method flogging::Logger::exiting"><code>exiting()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.exiting_with" title="method flogging::Logger::exiting_with"><code>exiting_with()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.file_logger" title="associated function flogging::Logger::file_logger"><code>file_logger()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.fine" title="method flogging::Logger::fine"><code>fine()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.finer" title="method flogging::Logger::finer"><code>finer()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.finest" title="method flogging::Logger::finest"><code>finest()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.fn_name" title="method flogging::Logger::fn_name"><code>fn_name()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.get_handler" title="method flogging::Logger::get_handler"><code>get_handler()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.has_handler" title="method flogging::Logger::has_handler"><code>has_handler()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.info" title="method flogging::Logger::info"><code>info()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.level" title="method flogging::Logger::level"><code>level()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.set_fn_name" title="method flogging::Logger::set_fn_name"><code>set_fn_name()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.set_level" title="method flogging::Logger::set_level"><code>set_level()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.severe" title="method flogging::Logger::severe"><code>severe()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.string_logger" title="associated function flogging::Logger::string_logger"><code>string_logger()</code></a></li>
<li><a href="api/flogging/struct.Logger.html#method.warning" title="method flogging::Logger::warning"><code>warning()</code></a></li>
</ul>
<h6 id="loggerbuilder"><a class="header" href="#loggerbuilder"><a class="doc-anchor" href="api/flogging/index.html#loggerbuilder">§</a>LoggerBuilder</a></h6>
<p><code>LoggerBuilder</code> is used by <code>Logger</code> to provide various configuration options for setting up your logger.
The available options/methods are:</p>
<ul>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_console_handler" title="method flogging::LoggerBuilder::add_console_handler"><code>add_console_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_console_handler_with" title="method flogging::LoggerBuilder::add_console_handler_with"><code>add_console_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_econsole_handler" title="method flogging::LoggerBuilder::add_econsole_handler"><code>add_econsole_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_econsole_handler_with" title="method flogging::LoggerBuilder::add_econsole_handler_with"><code>add_econsole_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_pconsole_handler" title="method flogging::LoggerBuilder::add_pconsole_handler"><code>add_console_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_pconsole_handler_with" title="method flogging::LoggerBuilder::add_pconsole_handler_with"><code>add_console_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_custom_handler" title="method flogging::LoggerBuilder::add_custom_handler"><code>add_custom_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>add_custom_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_file_handler" title="method flogging::LoggerBuilder::add_file_handler"><code>add_file_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_file_handler_with" title="method flogging::LoggerBuilder::add_file_handler_with"><code>add_file_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_string_handler" title="method flogging::LoggerBuilder::add_string_handler"><code>add_string_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_string_handler_with" title="method flogging::LoggerBuilder::add_string_handler_with"><code>add_string_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.remove_file" title="method flogging::LoggerBuilder::remove_file"><code>remove_file()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.set_fn_name" title="method flogging::LoggerBuilder::set_fn_name"><code>set_fn_name()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.set_level" title="method flogging::LoggerBuilder::set_level"><code>set_level()</code></a></li>
</ul>
<p>And to finish:</p>
<ul>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.build" title="method flogging::LoggerBuilder::build"><code>build()</code></a></li>
</ul>
<p>These options/methods allow you a lot of flexibility in how you configure your logger. As you will typically
have a different logger for each mod/file, you have a lot of control over what is logged, how it is formatted,
and where it is stored/viewed. With the <a href="api/flogging/struct.LoggerBuilder.html#method.set_level" title="method flogging::LoggerBuilder::set_level"><code>set_level()</code></a> method, you can control
this on a mod/file basis. Logging each mod/file differently, or even turning logging off when you no-longer require it.</p>
<p>Check out <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong> for examples and further help.</p>
<p><strong>Note</strong></p>
<p>As of version (0.4.0), you can only set the logging level for the logger. All handlers process every log entry
that the logger accepts, based on the logger’s current log level setting. This may change in a future version,
allowing each handler to have its own logging level.</p>
<h4 id="built-in-options"><a class="header" href="#built-in-options"><a class="doc-anchor" href="api/flogging/index.html#built-in-options">§</a>Built-in options</a></h4>
<p>I have included a number of handlers to get you started:</p>
<ul>
<li><a href="api/flogging/struct.ConsoleHandler.html" title="struct flogging::ConsoleHandler"><code>ConsoleHandler</code></a>
<ul>
<li><a href="api/flogging/enum.ConsoleType.html#variant.StdOut" title="variant flogging::ConsoleType::StdOut"><code>ConsoleType::StdOut</code></a></li>
<li><a href="api/flogging/enum.ConsoleType.html#variant.StdErr" title="variant flogging::ConsoleType::StdErr"><code>ConsoleType::StdErr</code></a></li>
<li><a href="api/flogging/enum.ConsoleType.html#variant.Production" title="variant flogging::ConsoleType::Production"><code>ConsoleType::Production</code></a></li>
</ul>
</li>
<li><a href="api/flogging/struct.FileHandler.html" title="struct flogging::FileHandler"><code>FileHandler</code></a></li>
<li><a href="api/flogging/struct.MockHandler.html" title="struct flogging::MockHandler"><code>MockHandler</code></a></li>
<li><a href="api/flogging/struct.StringHandler.html" title="struct flogging::StringHandler"><code>StringHandler</code></a></li>
</ul>
<p>There are also a number of formatters as well:</p>
<ul>
<li><a href="api/flogging/struct.Iso8601Formatter.html" title="struct flogging::Iso8601Formatter"><code>Iso8601Formatter</code></a></li>
<li><a href="api/flogging/struct.MockFormatter.html" title="struct flogging::MockFormatter"><code>MockFormatter</code></a></li>
<li><a href="api/flogging/struct.SimpleFormatter.html" title="struct flogging::SimpleFormatter"><code>SimpleFormatter</code></a></li>
<li><a href="api/flogging/struct.UnixTimestampFormatter.html" title="struct flogging::UnixTimestampFormatter"><code>UnixTimestampFormatter</code></a></li>
</ul>
<h4 id="customization"><a class="header" href="#customization"><a class="doc-anchor" href="api/flogging/index.html#customization">§</a>Customization</a></h4>
<ul>
<li><a href="api/flogging/index.html#custom-handler">Custom Handler</a></li>
<li><a href="api/flogging/index.html#custom-formatter">Custom Formatter</a></li>
</ul>
<p>Now for the fun part - “Doing it <em>your</em> way!!!”</p>
<p>Though I have provided some “standard” handlers and formatters, not everyone, or every project,
will want to use them. I expect there will be a need for:</p>
<ul>
<li>sending log entries to remote system log servers,</li>
<li>sending log entries to another program (local or remote) for live analysis, or some other processing,</li>
<li>storing log entries in a specific file format (xml, json, csv),</li>
<li>storing log entries in a database.</li>
</ul>
<p>And I’m sure you’ll come-up with more requirements at some time in the future. So, you have the option
to create your own custom handlers and custom formatters. Mixing them up with the built-in ones as
you need to.</p>
<p>OK now, how do you do it. Well this is going to require some work on your part.</p>
<hr />
<p>For a more in-depth tutorial refer to <strong><a href="https://bewillcott.github.io/flogging">The FLogging Guide</a></strong>.</p>
<hr />
<h5 id="custom-handler"><a class="header" href="#custom-handler"><a class="doc-anchor" href="api/flogging/index.html#custom-handler">§</a>Custom Handler</a></h5>
<p>To create a custom handler, I would suggest looking at the source code for the built-in ones, and copying
the code from the one that is closest to your requirements. <em>Make sure that you rename as appropriate!</em>
Then make the necessary changes, adding in your own code, to get it doing what you need.</p>
<p>When you are ready to try-out your new custom handler, check-out these methods:</p>
<ul>
<li><a href="api/flogging/struct.Logger.html#method.custom_logger" title="associated function flogging::Logger::custom_logger"><code>Logger::custom_logger()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_custom_handler" title="method flogging::LoggerBuilder::add_custom_handler"><code>LoggerBuilder::add_custom_handler()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>LoggerBuilder::add_custom_handler_with()</code></a></li>
</ul>
<h5 id="custom-formatter"><a class="header" href="#custom-formatter"><a class="doc-anchor" href="api/flogging/index.html#custom-formatter">§</a>Custom Formatter</a></h5>
<p>Now for the custom formatter. This may require a bit more investigation on your part, as to the actual
formatting options that are available.</p>
<p>Firstly, this crate uses <a href="https://crates.io/crates/chrono">crono</a> for the date/time functionality. Check
out the available <a href="https://docs.rs/chrono/latest/chrono/format/strftime">specifiers</a>. You will need to use the formatting options from this crate for the <code>dt_fmt</code> string, of your custom
formatter.</p>
<p>Secondly, the <code>fmt_string</code> uses the format options available in accordance with <a href="https://doc.rust-lang.org/1.89.0/alloc/fmt/index.html" title="mod alloc::fmt">std::fmt</a>. Though I am
actually using the <a href="https://crates.io/crates/strfmt">strfmt</a> crate to do the formatting, because it does
<em>not</em> require a ‘static’ string like <code>format!()</code>.</p>
<p>Again, check-out the built-in formatters, and copy the code from the one that is closest to your
requirements. <em>As before, renaming as necessary!</em> Also, check-out the trait: <a href="api/flogging/trait.FormatTrait.html"><code>FormatTrait</code></a>.
You will need to implement it for your custom formatter, as you will notice when you look at the built-in formatters.
Also, you will find that the ‘provided method’, <a href="api/flogging/trait.FormatTrait.html#method.ft_fmt" title="method flogging::FormatTrait::ft_fmt"><code>ft_fmt()</code></a>, provides certain variables
that you can include, via interpolation, in your <code>fmt_string</code>.</p>
<p>Once you have got your custom formatter set up, you can then use it with:</p>
<ul>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_console_handler_with" title="method flogging::LoggerBuilder::add_console_handler_with"><code>LoggerBuilder::add_console_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_econsole_handler_with" title="method flogging::LoggerBuilder::add_econsole_handler_with"><code>LoggerBuilder::add_econsole_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_pconsole_handler_with" title="method flogging::LoggerBuilder::add_pconsole_handler_with"><code>LoggerBuilder::add_pconsole_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_custom_handler_with" title="method flogging::LoggerBuilder::add_custom_handler_with"><code>LoggerBuilder::add_custom_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_file_handler_with" title="method flogging::LoggerBuilder::add_file_handler_with"><code>LoggerBuilder::add_file_handler_with()</code></a></li>
<li><a href="api/flogging/struct.LoggerBuilder.html#method.add_string_handler_with" title="method flogging::LoggerBuilder::add_string_handler_with"><code>LoggerBuilder::add_string_handler_with()</code></a></li>
</ul>
<h3 id="examples"><a class="header" href="#examples"><a class="doc-anchor" href="api/flogging/index.html#examples">§</a>Examples</a></h3>
<p>This example demonstrates the use of the macros. The reason I am demoing the macros, is that I expect most
people will want to use them, instead of the methods, for ease of use.</p>
<p>Let’s see what is required:</p>
<ol>
<li>At the module/file level:
<ul>
<li><code>use flogging::*;</code></li>
<li><code>const_logger!({...});</code><a href="api/flogging/macro.const_logger.html" title="macro flogging::const_logger">=&gt;</a></li>
</ul>
</li>
<li>On each function/method you want to add logging to:
<ul>
<li><code>#[logger]</code><a href="api/flogging/attr.logger.html" title="attr flogging::logger">=&gt;</a></li>
</ul>
</li>
<li>Inside each such attributed function/method:
<ul>
<li>Any of the logging <a href="api/flogging/index.html#macros-1">macros</a></li>
</ul>
</li>
</ol>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flogging::<span class="kw-2">*</span>;
<span class="kw">use </span>std::{error::Error, result::Result};
<p><span class="comment">// Setting up the module level logger.
</span><span class="macro">const_logger!</span>({
Logger::builder(<span class="macro">module_path!</span>())
.add_console_handler()
.add_file_handler(<span class="string">“test_logs/debug.log”</span>)
.set_level(Level::FINEST)
.build()
});</p>
<p><span class="attr">#[logger]
</span><span class="kw">fn </span>do_something() {
<span class="macro">entering!</span>();</p>
<pre><code>&lt;span class="comment"&gt;// do some work worth noting
&lt;/span&gt;&lt;span class="kw"&gt;let &lt;/span&gt;result = &lt;span class="string"&gt;"Just something to log."&lt;/span&gt;;
&lt;span class="macro"&gt;info!&lt;/span&gt;(&lt;span class="string"&gt;"Did some work here.\n  {result}"&lt;/span&gt;);

&lt;span class="comment"&gt;// ...

&lt;/span&gt;&lt;span class="macro"&gt;fine!&lt;/span&gt;(&lt;span class="string"&gt;"Bit more detail."&lt;/span&gt;);

&lt;span class="kw"&gt;if let &lt;/span&gt;&lt;span class="prelude-val"&gt;Err&lt;/span&gt;(e) = error_prone() {
    &lt;span class="macro"&gt;warning!&lt;/span&gt;(&lt;span class="string"&gt;"Error: {}"&lt;/span&gt;, e);
}

&lt;span class="macro"&gt;exiting!&lt;/span&gt;();
</code></pre>
<p>}</p>
<p><span class="attr">#[logger]
</span><span class="kw">fn </span>error_prone() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
<span class="macro">entering!</span>();
<span class="kw">let </span>rtn = <span class="prelude-val">Err</span>(Box::from(<span class="string">“Bad day!”</span>));
<span class="macro">exiting!</span>();
rtn
}</p>
<p><span class="attr">#[logger]
</span><span class="kw">fn </span>main() {
<span class="macro">entering!</span>();
<span class="macro">info!</span>(<span class="string">“All logging macros accept the same parameters as <code>std::format!(...)</code>”</span>);
<span class="macro">warning!</span>(<span class="string">“Those same macros (info, etc.) MUST have atleast one parameter.”</span>);
<span class="macro">config!</span>(<span class="string">“This is running on Fedora Linux 42.”</span>);
do_something();
<span class="macro">info!</span>(<span class="string">“Job’s done.”</span>);
<span class="macro">exiting!</span>();
}
</code></pre></div></p>
<p>Output:</p>
<div class="example-wrap"><pre class="language-code"><code>flogging-&gt;main [FINER  ] Entry
flogging-&gt;main [INFO   ] All logging macros accept the same parameters as `std::format!(...)`
flogging-&gt;main [WARNING] Those same macros (info, etc.) MUST have atleast one parameter.
flogging-&gt;main [CONFIG ] This is running on Fedora Linux 42.
flogging-&gt;do_something [FINER  ] Entry
flogging-&gt;do_something [INFO   ] Did some work here.
  Just something to log.
flogging-&gt;do_something [FINE   ] Bit more detail.
flogging-&gt;error_prone [FINER  ] Entry
flogging-&gt;error_prone [FINER  ] Return
flogging-&gt;do_something [WARNING] Error: Bad day!
flogging-&gt;do_something [FINER  ] Return
flogging-&gt;main [INFO   ] Job&#39;s done.
flogging-&gt;main [FINER  ] Return</code></pre></div></div></details><h2 id="macros-1" class="section-header"><a class="header" href="#macros-1">Macros<a href="api/flogging/index.html#macros-1" class="anchor">§</a></a></h2><dl class="item-table"><dt><a class="macro" href="api/flogging/macro.config.html" title="macro flogging::config">config</a></dt><dd>Log a CONFIG message.</dd><dt><a class="macro" href="api/flogging/macro.const_logger.html" title="macro flogging::const_logger">const_<wbr>logger</a></dt><dd>Setup module level logger access.</dd><dt><a class="macro" href="api/flogging/macro.entering.html" title="macro flogging::entering">entering</a></dt><dd>Log entry into a function/method.</dd><dt><a class="macro" href="api/flogging/macro.exiting.html" title="macro flogging::exiting">exiting</a></dt><dd>Log return from a function/method.</dd><dt><a class="macro" href="api/flogging/macro.fine.html" title="macro flogging::fine">fine</a></dt><dd>Log a FINE message.</dd><dt><a class="macro" href="api/flogging/macro.finer.html" title="macro flogging::finer">finer</a></dt><dd>Log a FINER message.</dd><dt><a class="macro" href="api/flogging/macro.finest.html" title="macro flogging::finest">finest</a></dt><dd>Log a FINEST message.</dd><dt><a class="macro" href="api/flogging/macro.get_handler.html" title="macro flogging::get_handler">get_<wbr>handler</a></dt><dd>Get the required <code>Handler</code>.</dd><dt><a class="macro" href="api/flogging/macro.info.html" title="macro flogging::info">info</a></dt><dd>Log an INFO message.</dd><dt><a class="macro" href="api/flogging/macro.is_logging.html" title="macro flogging::is_logging">is_<wbr>logging</a></dt><dd>Checks whether or not this logger is processing log requests.</dd><dt><a class="macro" href="api/flogging/macro.set_level.html" title="macro flogging::set_level">set_<wbr>level</a></dt><dd>Set the logging level for this <code>Logger</code> instance.</dd><dt><a class="macro" href="api/flogging/macro.severe.html" title="macro flogging::severe">severe</a></dt><dd>Log a SEVERE message.</dd><dt><a class="macro" href="api/flogging/macro.warning.html" title="macro flogging::warning">warning</a></dt><dd>Log a WARNING message.</dd></dl><h2 id="structs" class="section-header"><a class="header" href="#structs">Structs<a href="api/flogging/index.html#structs" class="anchor">§</a></a></h2><dl class="item-table"><dt><a class="struct" href="api/flogging/struct.ConsoleHandler.html" title="struct flogging::ConsoleHandler">Console<wbr>Handler</a></dt><dd>Publishes log entries to the console.</dd><dt><a class="struct" href="api/flogging/struct.ConsoleTypeError.html" title="struct flogging::ConsoleTypeError">Console<wbr>Type<wbr>Error</a></dt><dd>Returned from <code>FromStr::from_str()</code> when an unknown string
is passed-in.</dd><dt><a class="struct" href="api/flogging/struct.ConsoleTypeIter.html" title="struct flogging::ConsoleTypeIter">Console<wbr>Type<wbr>Iter</a></dt><dd>An iterator over the variants of <a href="api/flogging/enum.ConsoleType.html" title="enum flogging::ConsoleType">ConsoleType</a></dd><dt><a class="struct" href="api/flogging/struct.FileHandler.html" title="struct flogging::FileHandler">File<wbr>Handler</a></dt><dd>Publishes log entries to the file whose name was provided during
initialization.</dd><dt><a class="struct" href="api/flogging/struct.Iso8601Formatter.html" title="struct flogging::Iso8601Formatter">Iso8601<wbr>Formatter</a></dt><dd>ISO 8601 / RFC 3339 date &amp; time format.</dd><dt><a class="struct" href="api/flogging/struct.LogEntry.html" title="struct flogging::LogEntry">LogEntry</a></dt><dd>Used to provide relevant information about each log entry.</dd><dt><a class="struct" href="api/flogging/struct.Logger.html" title="struct flogging::Logger">Logger</a></dt><dd>This is the work-horse, providing the primary methods of the crate.</dd><dt><a class="struct" href="api/flogging/struct.LoggerBuilder.html" title="struct flogging::LoggerBuilder">Logger<wbr>Builder</a></dt><dd>Used by <a href="api/flogging/struct.Logger.html" title="struct flogging::Logger"><code>Logger</code></a> to provide more flexibility in the configuration of the
final logger.</dd><dt><a class="struct" href="api/flogging/struct.MockFormatter.html" title="struct flogging::MockFormatter">Mock<wbr>Formatter</a></dt><dd>Mock Formatter.</dd><dt><a class="struct" href="api/flogging/struct.MockHandler.html" title="struct flogging::MockHandler">Mock<wbr>Handler</a></dt><dd>This is used as a <em>fake</em> or <em>mock</em> handler.</dd><dt><a class="struct" href="api/flogging/struct.SimpleFormatter.html" title="struct flogging::SimpleFormatter">Simple<wbr>Formatter</a></dt><dd>Simple format.</dd><dt><a class="struct" href="api/flogging/struct.StringHandler.html" title="struct flogging::StringHandler">String<wbr>Handler</a></dt><dd>Publishes log entries to an internal list.</dd><dt><a class="struct" href="api/flogging/struct.UnixTimestampFormatter.html" title="struct flogging::UnixTimestampFormatter">Unix<wbr>Timestamp<wbr>Formatter</a></dt><dd>Unix Timestamp format.</dd></dl><h2 id="enums" class="section-header"><a class="header" href="#enums">Enums<a href="api/flogging/index.html#enums" class="anchor">§</a></a></h2><dl class="item-table"><dt><a class="enum" href="api/flogging/enum.ConsoleType.html" title="enum flogging::ConsoleType">Console<wbr>Type</a></dt><dd><code>ConsoleType</code> configures the <code>ConsoleHandler</code>’s output.</dd><dt><a class="enum" href="api/flogging/enum.FormatType.html" title="enum flogging::FormatType">Format<wbr>Type</a></dt><dd>Used as a simple way to obtain the various <a href="api/flogging/enum.Formatter.html" title="enum flogging::Formatter"><code>Formatter</code></a>s.</dd><dt><a class="enum" href="api/flogging/enum.Formatter.html" title="enum flogging::Formatter">Formatter</a></dt><dd>Provides wrappers for holding each type of formatter.</dd><dt><a class="enum" href="api/flogging/enum.Handler.html" title="enum flogging::Handler">Handler</a></dt><dd>Available handlers.</dd><dt><a class="enum" href="api/flogging/enum.Level.html" title="enum flogging::Level">Level</a></dt><dd>Log entry level setting.</dd></dl><h2 id="traits" class="section-header"><a class="header" href="#traits">Traits<a href="api/flogging/index.html#traits" class="anchor">§</a></a></h2><dl class="item-table"><dt><a class="trait" href="api/flogging/trait.FormatTrait.html" title="trait flogging::FormatTrait">Format<wbr>Trait</a></dt><dd>Provides methods for formatting <a href="api/flogging/struct.LogEntry.html" title="struct flogging::LogEntry"><code>LogEntry</code></a>s.</dd><dt><a class="trait" href="api/flogging/trait.HandlerTrait.html" title="trait flogging::HandlerTrait">Handler<wbr>Trait</a></dt><dd>Provides common methods required for all handlers.</dd></dl><h2 id="attributes" class="section-header"><a class="header" href="#attributes">Attribute Macros<a href="api/flogging/index.html#attributes" class="anchor">§</a></a></h2><dl class="item-table"><dt><a class="attr" href="api/flogging/attr.logger.html" title="attr flogging::logger">logger</a></dt><dd>Provides for logging within the attributed function/method.</dd></dl></section></div></main></body></html><div style="break-before: page; page-break-before: always;"></div><p>&lt;!doctype html&gt;<title>Coverage Report</title><link href=./style.css rel=stylesheet></head><body><div class=index-area><p class=index-title>Coverage Report</p><p class=index-date>Created at 2025-08-27 22:00</p><table class=index-table><thead><tr class=index-header><th>Filename</th><th colspan=3>Line Coverage <p class=level-text-veryhigh>99.85 %</p></th><th colspan=3>Function Coverage <p class=level-text-veryhigh>100.00 %</p></th><th colspan=3>Region Coverage <p class=level-text-veryhigh>99.62 %</p></th></tr></thead><tbody><tr><td><a href=./flogging_macros/src/format.rs.html>flogging_macros/src/format.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>38 / 38</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>2 / 2</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>64 / 64</td></tr><tr><td><a href=./flogging_macros/src/lib.rs.html>flogging_macros/src/lib.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>47 / 47</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>13 / 13</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>74 / 74</td></tr><tr><td><a href=./flogging_macros/src/logger.rs.html>flogging_macros/src/logger.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>14 / 14</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>1 / 1</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>20 / 20</td></tr><tr><td><a href=./src/handlers/console_handler/console_type.rs.html>src/handlers/console_handler/console_type.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>36 / 36</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>6 / 6</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>57 / 57</td></tr><tr><td><a href=./src/handlers/console_handler.rs.html>src/handlers/console_handler.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>185 / 185</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>20 / 20</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:99.4286%></div></div></td><td>99.43 %</td><td>348 / 350</td></tr><tr><td><a href=./src/handlers/file_handler.rs.html>src/handlers/file_handler.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:98.6577%></div></div></td><td>98.66 %</td><td>147 / 149</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>16 / 16</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:98.4962%></div></div></td><td>98.50 %</td><td>262 / 266</td></tr><tr><td><a href=./src/handlers/formatters/format_trait.rs.html>src/handlers/formatters/format_trait.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>28 / 28</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>4 / 4</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>58 / 58</td></tr><tr><td><a href=./src/handlers/formatters/format_type.rs.html>src/handlers/formatters/format_type.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>36 / 36</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>3 / 3</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>63 / 63</td></tr><tr><td><a href=./src/handlers/formatters/formatter.rs.html>src/handlers/formatters/formatter.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>20 / 20</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>4 / 4</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>46 / 46</td></tr><tr><td><a href=./src/handlers/formatters/iso8601_formatter.rs.html>src/handlers/formatters/iso8601_formatter.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>23 / 23</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>6 / 6</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>30 / 30</td></tr><tr><td><a href=./src/handlers/formatters/mock_formatter.rs.html>src/handlers/formatters/mock_formatter.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>22 / 22</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>6 / 6</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>28 / 28</td></tr><tr><td><a href=./src/handlers/formatters/mod.rs.html>src/handlers/formatters/mod.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>65 / 65</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>4 / 4</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>146 / 146</td></tr><tr><td><a href=./src/handlers/formatters/simple_formatter.rs.html>src/handlers/formatters/simple_formatter.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>23 / 23</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>6 / 6</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>30 / 30</td></tr><tr><td><a href=./src/handlers/formatters/unixtimestamp_formatter.rs.html>src/handlers/formatters/unixtimestamp_formatter.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>23 / 23</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>6 / 6</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>30 / 30</td></tr><tr><td><a href=./src/handlers/handler.rs.html>src/handlers/handler.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>24 / 24</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>2 / 2</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>58 / 58</td></tr><tr><td><a href=./src/handlers/mock_handler.rs.html>src/handlers/mock_handler.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>45 / 45</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>11 / 11</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>80 / 80</td></tr><tr><td><a href=./src/handlers/string_handler.rs.html>src/handlers/string_handler.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>63 / 63</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>13 / 13</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>104 / 104</td></tr><tr><td><a href=./src/logger/builder.rs.html>src/logger/builder.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>295 / 295</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>32 / 32</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:99.3617%></div></div></td><td>99.36 %</td><td>467 / 470</td></tr><tr><td><a href=./src/logger/level.rs.html>src/logger/level.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>43 / 43</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>5 / 5</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>64 / 64</td></tr><tr><td><a href=./src/logger/log_entry.rs.html>src/logger/log_entry.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>48 / 48</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>10 / 10</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>81 / 81</td></tr><tr><td><a href=./src/logger/mod.rs.html>src/logger/mod.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>116 / 116</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>30 / 30</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>202 / 202</td></tr><tr><td><a href=./src/logger/tests.rs.html>src/logger/tests.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>21 / 21</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>3 / 3</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>54 / 54</td></tr><tr><td><a href=./src/macros.rs.html>src/macros.rs</a></td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>1 / 1</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>1 / 1</td><td><div class=progress-bar><div class=level-bg-veryhigh style=width:100%></div></div></td><td>100.00 %</td><td>1 / 1</td></tr></tbody></table></div><p class=page-footer>Generated by <a href=https://github.com/dnaka91/llvm-cov-pretty>llvm-cov-pretty</a> – version 0.1.10</p></body></html></p>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD024 MD042 MD033 -->
<h1 id="release-log"><a class="header" href="#release-log">Release Log</a></h1>
<h2 id="version-060----2025-08-27"><a class="header" href="#version-060----2025-08-27">Version 0.6.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.6.0" title="" target="_blank">*</a> - 2025-08-27</a></h2>
<hr />
<p><em><strong>Important Notes:</strong></em></p>
<ul>
<li>
<p>Removed</p>
<pre><code class="language-rust  no_run  noplayground">impl Handler{
    fn new(){...}
    fn create(name){...}
}</code></pre>
</li>
<li>
<p>Removed</p>
<pre><code class="language-rust  no_run  noplayground">Logger::reset_level()</code></pre>
</li>
</ul>
<p>Both of the above APIs are redundant. So removing them now, before v1.0.0 is released, is best.</p>
<ul>
<li>Added a new method to <code>HandlerTrait</code> - <code>set_test_mode()</code>. This will require updating of any custom handlers.</li>
</ul>
<hr />
<h3 id="great-news"><a class="header" href="#great-news">Great News</a></h3>
<p>Initial release of the online instructional guide: <a href="https://bewillcott.github.io/flogging/" title="" target="_blank">The FLogging Guide</a>.</p>
<hr />
<p>Added new methods to <code>LoggerBuilder</code>:</p>
<ul>
<li><code>remove_file()</code>
<ul>
<li>Use to remove a log file before adding a file handler.
This is a way of resetting the log file prior to each test run.</li>
</ul>
</li>
<li><code>add_pconsole_handler()</code> and <code>add_pconsole_handler_with()</code>
<ul>
<li>Use to add a production version of the console handler. This handler is different, in that log entries set to <code>LeveL::INFO</code>, will have their <code>msg</code> printed to <code>stdout</code> without any formatting, whilst all other <code>Level</code>s will be printed to <code>stderr</code> using the set formatter.</li>
</ul>
</li>
<li><code>set_fn_name()</code>
<ul>
<li>Set the current function/method name. Only required when using the <em>method</em> form of operation instead of the <em>macro</em> form.</li>
</ul>
</li>
</ul>
<p>Added new method to <code>Logger</code> - <code>pconsole_logger()</code>.
Added new associative function to <code>Logger</code> - <code>remove_file()</code>.</p>
<p>To facilitate the <em>pconcole_handlers</em>, a new enum <code>ConsoleType</code> has been added.</p>
<p>Extensive work done on improving both unit and integration tests.</p>
<h2 id="version-050----2025-08-03"><a class="header" href="#version-050----2025-08-03">Version 0.5.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.5.0" title="" target="_blank">*</a> - 2025-08-03</a></h2>
<details>
<summary>Details (click to see)</summary>
<hr />
<p><em><strong>Important Note:</strong></em></p>
<p>Only applicable for those who have previously created their own custom formatter - <code>FormatType::Custom(String)</code> changed to <code>FormatType::Custom</code>.</p>
<hr />
<p>Now generally, there were some improvements to the API documentation.</p>
</details>
<h2 id="version-041----2025-07-29"><a class="header" href="#version-041----2025-07-29">Version 0.4.1 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.4.1" title="" target="_blank">*</a> - 2025-07-29</a></h2>
<details>
<summary>Details (click to see)</summary>
<ul>
<li>Major improvements to the API documentation.</li>
<li>Increased test coverage to 100%, and included the <a href="https://bewillcott.github.io/flogging/coverage" title="" target="_blank">Coverage Report</a>.</li>
</ul>
</details>
<h2 id="version-040----2025-07-27"><a class="header" href="#version-040----2025-07-27">Version 0.4.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v-0.4.0" title="" target="_blank">*</a> - 2025-07-27</a></h2>
<details>
<summary>Details (click to see)</summary>
<p>This is the initial release.</p>
<p>The reason for not being (0.1.0), is the way I track the internal development
of projects not yet published. However, now that this one is published,
the versioning will progress as expected, in accordance with <a href="https://semver.org/" title="" target="_blank">Semantic Versioning</a>.</p>
</details>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD024 MD042 MD033 -->
<h1 id="changelog"><a class="header" href="#changelog">Changelog <a href="https://common-changelog.org" title="" target="_blank"><img src="https://common-changelog.org/badge.svg" alt="Common Changelog"></a></a></h1>
<h2 id="version-060----2025-08-27-1"><a class="header" href="#version-060----2025-08-27-1">Version 0.6.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.6.0" title="" target="_blank">*</a> - 2025-08-27</a></h2>
<ul>
<li>Initial release of the online Guide: “The FLogging Guide”. (<a href="https://github.com/bewillcott/flogging/commit/ebe97fc99c17ca31339c908b5301512547553068" title="" target="_blank">
<code>ebe97fc</code></a>)</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<ul>
<li><strong>Breaking:</strong> Minor change to the <code>Iso8601Formatter::fmt_string</code>. (<a href="https://github.com/bewillcott/flogging/commit/16a7e87e5a51e8aac4b01a5c6de53ea78ab92439" title="" target="_blank">
<code>16a7e87</code></a>)</li>
<li><strong>Breaking:</strong> Minor change to the <code>SimpleFormatter::fmt_string</code> and <code>UnixTimestampFormatter::fmt_string</code>. (<a href="https://github.com/bewillcott/flogging/commit/5a435f75ff9baee54d02c725018561beadc273f6" title="" target="_blank">
<code>5a435f7</code></a>)</li>
<li>Change: <code>ConsoleHandler</code> contains <code>console_type: ConsoleType</code> instead of <code>stderr: bool</code>.<br />
(<a href="https://github.com/bewillcott/flogging/commit/aeceb233270f7745b2ff7dbcb44d01ce68098f45" title="" target="_blank">
<code>aeceb23</code></a>)</li>
<li>Change: Name: <code>impl ConsoleHandler::create()</code> to: <code>impl ConsoleHandler::_create()</code>. (<a href="https://github.com/bewillcott/flogging/commit/4a24410b82ae9f09a25e4bacf81663418f5da01b" title="" target="_blank">
<code>4a24410</code></a>)</li>
<li>Change: Name: <code>impl FileHandler::create()</code> to: <code>impl FileHandler::_create()</code>. (<a href="https://github.com/bewillcott/flogging/commit/e08498ecf6e1c46310ec66bd5ae2961faf7c8264" title="" target="_blank">
<code>e08498e</code></a>)</li>
<li>Change: Update and improve tests. (<a href="https://github.com/bewillcott/flogging/commit/b51d4ba470d12e3cb88163f7c2d51781a060e693" title="" target="_blank">
<code>b51d4ba</code></a>)</li>
<li>Change: Many updates to the Guide.<br />
(<a href="https://github.com/bewillcott/flogging/commit/0d4e7388040a205bc013385e173cb7efb36e4a4d" title="" target="_blank">
<code>0d4e738</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/b16e26076bbf731c662f40ed01ec4c73ae176183" title="" target="_blank">
<code>b16e260</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/bda2ef33cb41504ac4a06150cc12e9a98b039209" title="" target="_blank">
<code>bda2ef3</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/3a0bd0b74a57449ae786771165d482dc3cc9fae0" title="" target="_blank">
<code>3a0bd0b</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/b997cbbec8983217ea3cb8b7efecab2c5640e6f6" title="" target="_blank">
<code>b997cbb</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/bd3c370702c882a4232a78634c49733eda02841f" title="" target="_blank">
<code>bd3c370</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/af573a376cc99f5cccbac8a9572d88f4216c472c" title="" target="_blank">
<code>af573a3</code></a>)</li>
<li>Change: Update Guide, remove <code>api</code> and <code>coverage</code> directories from source control. (<a href="https://github.com/bewillcott/flogging/commit/f8acd757979fc1a1b985d901ba347e2c01e68fdd" title="" target="_blank">
<code>f8acd75</code></a>)</li>
<li>Change: Various improvements to the documentation. (<a href="https://github.com/bewillcott/flogging/commit/19c327aeff87a9550effe2218115144c85012f71" title="" target="_blank">
<code>19c327a</code></a>)</li>
</ul>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<ul>
<li><strong>Breaking</strong> Add: New method to <code>HandlerTrait</code> - <code>set_test_mode()</code>. (<a href="https://github.com/bewillcott/flogging/commit/0fc162bf5898c0fe3cc5a8f89c069cfe83baa9c4" title="" target="_blank">
<code>0fc162b</code></a>)</li>
<li>Add: New instructional Guide. (<a href="https://github.com/bewillcott/flogging/commit/73d048a44d1effb496d01213ad549b28bfdf027e" title="" target="_blank">
<code>73d048a</code></a>)</li>
<li>Add: New <code>LoggerBuilder</code> method: <code>remove_file()</code>. (<a href="https://github.com/bewillcott/flogging/commit/f9d5b9537960dd23af9f76b77ff5a4b996e777bd" title="" target="_blank">
<code>f9d5b95</code></a>)</li>
<li>Add: New <code>LoggerBuilder</code> method: <code>set_fn_name()</code>. (<a href="https://github.com/bewillcott/flogging/commit/0a76ce27ce98047045889f24f56684e1d44b9ec7" title="" target="_blank">
<code>0a76ce2</code></a>)</li>
<li>Add: <code>enum ConsoleType</code>. (<a href="https://github.com/bewillcott/flogging/commit/b0f404b26858b4b9b1e6839b1769049e6deb2e65" title="" target="_blank">
<code>b0f404b</code></a>)</li>
<li>Add: New <code>LoggerBuilder</code> methods: <code>add_pconsole_handler()</code> and <code>add_pconsole_handler_with()</code>. (<a href="https://github.com/bewillcott/flogging/commit/85bbe5a79320f19091abe1f11d06a962f29c2863" title="" target="_blank">
<code>85bbe5a</code></a>)</li>
<li>Add: New method to <code>Logger</code> - <code>pconsole_logger()</code>. (<a href="https://github.com/bewillcott/flogging/commit/29bef4580276b64cf91bcbb156ce890d27110df6" title="" target="_blank">
<code>29bef45</code></a>)</li>
<li>Add: New <code>Logger</code> associative function: <code>remove_file()</code>. (<a href="https://github.com/bewillcott/flogging/commit/9f848fdbb8fbf366bdc2f775091bd4297fc11f3b" title="" target="_blank">
<code>9f848fd</code></a>)</li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<ul>
<li><strong>Breaking:</strong> Remove <code>impl Handler{...}</code> - <code>new()</code> and <code>create(name)</code>. (<a href="https://github.com/bewillcott/flogging/commit/362319610c1f82c8be9ceb7c7d4c3a87637017fa" title="" target="_blank">
<code>3623196</code></a>)</li>
<li><strong>Breaking:</strong> Removed <code>Logger::reset_level()</code>. No longer applicable. Use <code>Logger::set_level()</code>. (<a href="https://github.com/bewillcott/flogging/commit/153c324caad9ad2942104ad801bc80b47d97b0ee" title="" target="_blank">
<code>153c324</code></a>)</li>
<li>Remove: <code>main.rs</code> from project. (<a href="https://github.com/bewillcott/flogging/commit/6a2a3ccbbbfa8ca36827ebad7fb2b2a18e8da643" title="" target="_blank">
<code>6a2a3cc</code></a>)</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li>Fix: Many tests due to new and modified API and internal code. (<a href="https://github.com/bewillcott/flogging/commit/0c6aa2f9521085870144c3e200429133f910469a" title="" target="_blank">
<code>0c6aa2f</code></a>)</li>
</ul>
<h2 id="version-050----2025-08-03-1"><a class="header" href="#version-050----2025-08-03-1">Version 0.5.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.5.0" title="" target="_blank">*</a> - 2025-08-03</a></h2>
<details>
<summary>Details (click to see)</summary>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><strong>Breaking:</strong> Modified <code>FormatType::Custom(String)</code> to <code>FormatType::Custom</code>. (<a href="https://github.com/bewillcott/flogging/commit/88183d392edda04b7f7f6bc24165c481991818ef" title="" target="_blank">
<code>88183d3</code></a>)</li>
<li>Document: Convert inline links to reference links. (<a href="https://github.com/bewillcott/flogging/commit/e5a7bf0027c386ad229ea74cfcc3483274e51580" title="" target="_blank">
<code>e5a7bf0</code></a>)</li>
<li>Change: <code>ConsoleHandler</code> to contain <code>stderr: bool</code> instead of <code>mod_path: String</code>. Will now output to <code>std::io::stderr</code> if true. (<a href="https://github.com/bewillcott/flogging/commit/41f5e9e047e8cb3fea6cb664f84f9d0f621c89de" title="" target="_blank">
<code>41f5e9e</code></a>)</li>
<li>Change: <code>StringHandler</code> removed <code>name: String</code> and renamed private method <code>StringHandler::create()</code> to <code>StringHandler::new()</code>. (<a href="https://github.com/bewillcott/flogging/commit/41f5e9e047e8cb3fea6cb664f84f9d0f621c89de" title="" target="_blank">
<code>41f5e9e</code></a>)</li>
</ul>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<ul>
<li>Add: Macro and method: <code>is_logging</code>. (<a href="https://github.com/bewillcott/flogging/commit/ee882f370a8eb87ef6e152194c869c42a15c19a1" title="" target="_blank">
<code>ee882f3</code></a>)</li>
<li>Add: <code>econsole_logger()</code> and <code>add_econsole_handler()</code>. (<a href="https://github.com/bewillcott/flogging/commit/41f5e9e047e8cb3fea6cb664f84f9d0f621c89de" title="" target="_blank">
<code>41f5e9e</code></a>)</li>
<li>Add: <code>Handler::EConsole</code>. (<a href="https://github.com/bewillcott/flogging/commit/41f5e9e047e8cb3fea6cb664f84f9d0f621c89de" title="" target="_blank">
<code>41f5e9e</code></a>)</li>
</ul>
</details>
<h2 id="version-041----2025-07-29-1"><a class="header" href="#version-041----2025-07-29-1">Version 0.4.1 <a href="https://github.com/bewillcott/flogging/releases/tag/v0.4.1" title="" target="_blank">*</a> - 2025-07-29</a></h2>
<details>
<summary>Details (click to see)</summary>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<ul>
<li>Document comments improved or expanded. (<a href="https://github.com/bewillcott/flogging/commit/d35d3e5e8eb0a443b8b71a1f94ba9ea0faca0775" title="" target="_blank">
<code>d35d3e5</code></a>)</li>
</ul>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>Minimum Rust version now set to: “1.85.1”. (<a href="https://github.com/bewillcott/flogging/commit/3c6e99ae0e38ac5f63540f47176df9fb6667d524" title="" target="_blank">
<code>3c6e99a</code></a>)</li>
<li>Test coverage improved. Now 100%. (<a href="https://github.com/bewillcott/flogging/commit/d35d3e5e8eb0a443b8b71a1f94ba9ea0faca0775" title="" target="_blank">
<code>d35d3e5</code></a>)</li>
<li><a href="https://bewillcott.github.io/flogging/coverage" title="" target="_blank">Coverage Report</a></li>
</ul>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li>Fix broken documentation links. (<a href="https://github.com/bewillcott/flogging/commit/3e32c9095ecef4994ecb0dd44268d5025010c0cf" title="" target="_blank">
<code>3e32c90</code></a>) (<a href="https://github.com/bewillcott/flogging/commit/5ca139a11ef961f9b48181b76a142eb703e8b34b" title="" target="_blank">
<code>5ca139a</code></a>)</li>
</ul>
</details>
<h2 id="version-040----2025-07-27-1"><a class="header" href="#version-040----2025-07-27-1">Version 0.4.0 <a href="https://github.com/bewillcott/flogging/releases/tag/v-0.4.0" title="" target="_blank">*</a> - 2025-07-27</a></h2>
<p><em>Initial release.</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
